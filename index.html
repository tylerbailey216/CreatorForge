<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CreatorForge ‚Äì Fast Tools for Creators</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #05070b;
      --bg-elevated: #101521;
      --card: #151c2a;
      --accent: #a0f0ff;
      --accent-soft: #ea8bfa;
      --accent-warm: #ffd59b;
      --text: #f8f9ff;
      --muted: #9ea8c4;
      --danger: #ff6b81;
      --radius-lg: 20px;
      --radius-md: 14px;
      --shadow-soft: 0 22px 60px rgba(0, 0, 0, 0.7);
      --border-subtle: 1px solid rgba(255, 255, 255, 0.06);
      --app-max-width: 1420px;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
    }

    html, body {
      margin: 0;
      padding: 0;
      max-width: 100%;
      overflow-x: hidden;
    }

    body {
      background: radial-gradient(circle at top, #1d2950 0, #05070b 58%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: var(--app-max-width);
      padding: 24px 18px 44px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .brand-mark {
      width: 34px;
      height: 34px;
      border-radius: 999px;
      background: conic-gradient(
        from 210deg,
        #a0f0ff,
        #ea8bfa,
        #ffd59b,
        #a0f0ff
      );
      box-shadow: 0 0 18px rgba(160, 240, 255, 0.6);
      position: relative;
      overflow: hidden;
      animation: orbitGlow 8s linear infinite;
    }

    .brand-mark::after {
      content: "";
      position: absolute;
      inset: 5px;
      border-radius: inherit;
      background: rgba(5, 7, 11, 0.96);
    }

    .brand-mark-inner {
      position: absolute;
      inset: 7px;
      border-radius: inherit;
      border: 1px solid rgba(160, 240, 255, 0.65);
      box-shadow: 0 0 14px rgba(160, 240, 255, 0.75);
    }

    .brand-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .brand-text-title {
      font-size: 1.15rem;
      letter-spacing: 0.05em;
      font-weight: 650;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .brand-text-subtitle {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .beta-pill {
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(160, 240, 255, 0.7);
      color: var(--accent);
      background: rgba(5, 10, 18, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .header-actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .pill {
      font-size: 0.75rem;
      padding: 6px 10px;
      border-radius: 999px;
      border: var(--border-subtle);
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(9, 13, 22, 0.75);
      backdrop-filter: blur(12px);
    }

    .pill span.emoji {
      font-size: 0.9rem;
    }

    .btn-outline {
      border-radius: 999px;
      padding: 7px 14px;
      font-size: 0.8rem;
      border: 1px solid rgba(160, 240, 255, 0.7);
      background: rgba(6, 10, 20, 0.9);
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.2s ease, transform 0.15s ease,
        box-shadow 0.2s ease;
      box-shadow: 0 0 12px rgba(160, 240, 255, 0.25);
    }

    .btn-outline:hover {
      background: rgba(23, 30, 50, 0.98);
      transform: translateY(-1px);
      box-shadow: 0 0 18px rgba(160, 240, 255, 0.45);
    }

    .hero {
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: radial-gradient(circle at top left, #283555 0, #0b0f15 55%);
      box-shadow: var(--shadow-soft);
      padding: 18px 18px 18px;
      margin-bottom: 24px;
      display: grid;
      grid-template-columns: minmax(0, 3.1fr) minmax(0, 2.4fr);
      gap: 20px;
      align-items: center;
    }

    .hero-main-title {
      font-size: 1.75rem;
      line-height: 1.18;
      margin-bottom: 8px;
    }

    .hero-main-title span.accent {
      background: linear-gradient(120deg, #a0f0ff, #ea8bfa, #ffd59b);
      -webkit-background-clip: text;
      color: transparent;
    }

    .hero-body {
      font-size: 0.95rem;
      color: var(--muted);
      margin-bottom: 12px;
      max-width: 430px;
    }

    .hero-body strong {
      color: #dfe6ff;
    }

    .hero-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }

    .hero-tag {
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(5, 9, 18, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.07);
      color: var(--muted);
    }

    .hero-footer-note {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .hero-visual {
      border-radius: var(--radius-md);
      border: 1px solid rgba(160, 240, 255, 0.28);
      background: radial-gradient(circle at top, #304a6f 0, #0b1017 55%);
      padding: 12px 14px 14px;
      position: relative;
      overflow: hidden;
    }

    .hero-visual-title {
      font-size: 0.78rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .hero-visual-main {
      font-size: 0.9rem;
      margin-bottom: 10px;
      color: #e9f1ff;
    }

    .hero-visual-matrix {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      font-size: 0.7rem;
    }

    .matrix-chip {
      border-radius: 999px;
      background: rgba(7, 13, 26, 0.9);
      border: 1px solid rgba(160, 240, 255, 0.42);
      padding: 5px 8px;
      display: flex;
      align-items: center;
      gap: 5px;
      color: #cfd9ff;
    }

    .matrix-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #a0f0ff;
      box-shadow: 0 0 8px rgba(160, 240, 255, 0.85);
    }

    .hero-visual-orbit {
      position: absolute;
      inset: -40%;
      border-radius: 50%;
      border: 1px dashed rgba(160, 240, 255, 0.18);
      pointer-events: none;
      animation: orbit 18s linear infinite;
    }

    .hero-visual-orbit:nth-child(1) { transform: scale(1.05); }
    .hero-visual-orbit:nth-child(2) { transform: scale(1.35); opacity: 0.7; animation-duration: 26s; }
    .hero-visual-orbit:nth-child(3) { transform: scale(1.7); opacity: 0.4; animation-duration: 34s; }

    .section-title {
      font-size: 0.95rem;
      margin-bottom: 10px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-title span.dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(160, 240, 255, 0.8);
    }

    .tool-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
      align-items: stretch;
    }

    @media (max-width: 880px) {
      .hero {
        grid-template-columns: minmax(0, 1.2fr);
      }
      .tool-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 640px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      .hero {
        padding: 16px;
      }
      .tool-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .tool-card {
      border-radius: var(--radius-md);
      border: var(--border-subtle);
      background: radial-gradient(circle at top left, #242f45 0, #101621 60%);
      padding: 13px 13px 12px;
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.45);
      display: flex;
      flex-direction: column;
      gap: 8px;
      position: relative;
      overflow: hidden;
      transition: transform 0.16s ease, box-shadow 0.2s ease, border-color 0.18s ease;
      cursor: pointer;
      min-height: 142px;
    }

    .tool-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(160, 240, 255, 0.15), transparent 55%);
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
    }

    .tool-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.7);
      border-color: rgba(160, 240, 255, 0.35);
    }

    .tool-card:hover::before {
      opacity: 1;
    }

    .tool-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .tool-title {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .tool-tag {
      font-size: 0.65rem;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(5, 10, 18, 0.9);
      border: 1px solid rgba(160, 240, 255, 0.35);
      color: var(--muted);
    }

    .tool-body {
      font-size: 0.78rem;
      color: var(--muted);
      min-height: 32px;
    }

    .tool-bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 4px;
      gap: 8px;
    }

    .tool-meta {
      font-size: 0.7rem;
      color: #8f9bb6;
    }

    .btn-small {
      font-size: 0.75rem;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(160, 240, 255, 0.7);
      background: rgba(5, 10, 18, 0.96);
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: background 0.18s ease, transform 0.12s ease, box-shadow 0.15s ease;
    }

    .btn-small:hover:not(:disabled) {
      background: rgba(23, 31, 53, 1);
      transform: translateY(-1px);
      box-shadow: 0 0 14px rgba(160, 240, 255, 0.45);
    }

    .btn-small:disabled {
      border-style: dashed;
      opacity: 0.6;
      cursor: default;
    }

    .workspace {
      border-radius: var(--radius-lg);
      border: var(--border-subtle);
      background: linear-gradient(135deg, #141a23 0, #080b12 55%);
      box-shadow: var(--shadow-soft);
      padding: 18px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 16px;
      align-items: start;
    }

    @media (max-width: 960px) {
      .workspace {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 720px) {
      .workspace {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .panel {
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: radial-gradient(circle at top left, #202939 0, #090c13 60%);
      padding: 16px 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      position: relative;
      overflow: hidden;
    }

    .panel > * {
      min-width: 0;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 8px;
      gap: 6px;
    }

    .panel-header-right {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .panel-title {
      font-weight: 500;
      color: #e3ebff;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .panel-title span.emoji {
      font-size: 0.92rem;
    }

    .hint {
      font-size: 0.7rem;
      color: var(--muted);
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      padding: 0 5px;
      cursor: help;
      line-height: 1.4;
    }

    label {
      font-size: 0.72rem;
      color: var(--muted);
      display: block;
      margin-bottom: 2px;
    }

    input[type="file"],
    input[type="text"],
    input[type="number"],
    input[type="color"],
    select,
    textarea {
      width: 100%;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(7, 10, 18, 0.95);
      color: var(--text);
      padding: 6px 8px;
      font-size: 0.78rem;
      outline: none;
    }

    input[type="color"] {
      padding: 0;
      height: 28px;
      cursor: pointer;
    }

    textarea {
      resize: vertical;
      min-height: 64px;
    }

    input::placeholder,
    textarea::placeholder {
      color: #5b6680;
    }

    input:focus,
    select:focus,
    textarea:focus {
      border-color: rgba(160, 240, 255, 0.8);
      box-shadow: 0 0 0 1px rgba(160, 240, 255, 0.28);
    }

    .inline-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .chip {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 3px 8px;
      font-size: 0.7rem;
      color: var(--muted);
      cursor: pointer;
      background: rgba(7, 10, 18, 0.95);
      transition: border-color 0.16s ease, color 0.16s ease, box-shadow 0.16s ease, background 0.16s ease;
    }

    .chip.active {
      border-color: rgba(160, 240, 255, 0.9);
      color: var(--accent);
      box-shadow: 0 0 12px rgba(160, 240, 255, 0.45);
      background: rgba(16, 26, 45, 0.98);
    }

    .result-box {
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(4, 7, 13, 0.95);
      padding: 6px 7px;
      font-size: 0.75rem;
      color: #d3ddff;
      max-height: 160px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(5, 10, 18, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--muted);
    }

    .badge.success {
      color: #8effc7;
      border-color: rgba(142, 255, 199, 0.9);
    }

    .badge.danger {
      color: var(--danger);
      border-color: rgba(255, 107, 129, 0.9);
    }

    .badge.warn {
      color: #ffd27b;
      border-color: rgba(255, 210, 123, 0.9);
    }

    .tiny {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .planner-list {
      list-style: none;
      padding: 0;
      margin: 4px 0 0;
      max-height: 140px;
      overflow: auto;
      font-size: 0.78rem;
    }

    .planner-list li {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 0;
      border-bottom: 1px dashed rgba(255, 255, 255, 0.03);
    }

    .planner-list li:last-child {
      border-bottom: none;
    }

    .planner-title {
      font-weight: 500;
    }

    .planner-meta {
      font-size: 0.68rem;
      color: var(--muted);
    }

    .link-rating {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-top: 2px;
    }

    .pill-soft {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(5, 10, 18, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.06);
      color: var(--muted);
    }

    .footer-note {
      margin-top: 10px;
      font-size: 0.7rem;
      color: var(--muted);
      text-align: right;
    }

    .canvas-preview {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: radial-gradient(circle at top, #1a2236 0, #05070b 60%);
      display: block;
    }

    .tool-live-preview-pane {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(6, 10, 17, 0.88);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
      align-self: start;
    }

    .tool-live-preview-window {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background:
        linear-gradient(45deg, rgba(255,255,255,0.04) 25%, transparent 25%) 0 0 / 18px 18px,
        linear-gradient(-45deg, rgba(255,255,255,0.04) 25%, transparent 25%) 0 9px / 18px 18px,
        linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.03) 75%) 9px -9px / 18px 18px,
        linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.03) 75%) -9px 0 / 18px 18px,
        radial-gradient(circle at top, #1a2236 0, #05070b 65%);
      min-height: 220px;
      max-height: min(52vh, 520px);
      overflow: auto;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px;
      position: relative;
    }

    .tool-live-preview-window[data-preview-frame="portrait"] {
      aspect-ratio: 9 / 16;
      min-height: 300px;
      max-height: min(64vh, 700px);
    }

    .tool-live-preview-window[data-preview-frame="landscape"] {
      aspect-ratio: 16 / 9;
      min-height: 180px;
    }

    .tool-live-preview-window[data-preview-frame="square"] {
      aspect-ratio: 1 / 1;
      min-height: 220px;
    }

    .tool-live-preview-window .canvas-preview {
      width: 100%;
      max-height: min(48vh, 480px);
      object-fit: contain;
      flex: 0 0 auto;
    }

    .tool-live-preview-empty {
      font-size: 0.75rem;
      color: var(--muted);
      text-align: center;
      max-width: 260px;
      line-height: 1.35;
      padding: 8px;
    }

    .tool-live-preview-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tool-live-preview-meta .tiny {
      width: 100%;
    }

    .tool-live-preview-frame-row {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tool-live-preview-frame-row label {
      margin: 0;
      font-size: 0.68rem;
      color: var(--muted);
      white-space: nowrap;
    }

    .tool-live-preview-frame-row select {
      width: auto;
      min-width: 132px;
      font-size: 0.72rem;
      padding: 5px 8px;
    }

    .tool-live-preview-status {
      min-height: 16px;
    }

    .tool-live-preview-note {
      font-size: 0.68rem;
      color: var(--muted);
      line-height: 1.35;
    }

    .range-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .range-row input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
    }

    .range-row span {
      font-size: 0.72rem;
      color: var(--muted);
      min-width: 28px;
      text-align: right;
    }

    .collage-canvas {
      touch-action: none;
      cursor: grab;
      min-height: 180px;
      max-height: min(62vh, 640px);
      object-fit: contain;
    }

    .collage-canvas.dragging {
      cursor: grabbing;
    }

    .collage-slot-list {
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(4, 7, 13, 0.95);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 260px;
      overflow: auto;
    }

    .collage-slot-row {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 6px;
      align-items: center;
    }

    .collage-slot-row label {
      margin: 0;
      font-size: 0.68rem;
      color: var(--muted);
      min-width: 38px;
    }

    .collage-slot-row select {
      min-width: 0;
    }

    .collage-tile-pill {
      font-size: 0.65rem;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(8, 12, 20, 0.9);
      color: var(--muted);
      cursor: pointer;
    }

    .collage-tile-pill.active {
      color: var(--accent);
      border-color: rgba(160, 240, 255, 0.85);
      box-shadow: 0 0 12px rgba(160, 240, 255, 0.28);
    }

    .collage-selection-row {
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }

    .collage-selection-row .tiny {
      flex: 1;
      text-align: right;
    }

    .collage-status {
      min-height: 16px;
    }

    .collage-preview-note {
      font-size: 0.68rem;
      color: var(--muted);
    }

    .bgremover-preview-wrap {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background:
        linear-gradient(45deg, rgba(255,255,255,0.05) 25%, transparent 25%) 0 0 / 20px 20px,
        linear-gradient(-45deg, rgba(255,255,255,0.05) 25%, transparent 25%) 0 10px / 20px 20px,
        linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.04) 75%) 10px -10px / 20px 20px,
        linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.04) 75%) -10px 0 / 20px 20px,
        radial-gradient(circle at top, #1a2236 0, #05070b 60%);
      overflow: hidden;
      position: relative;
      overflow: auto;
      max-height: min(58vh, 560px);
      min-height: 260px;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 6px;
    }

    .bgremover-canvas {
      width: 100%;
      display: block;
      background: transparent;
      max-height: 340px;
      object-fit: contain;
    }

    .bgremover-live-preview-canvas {
      display: block;
      background: transparent;
      width: 100%;
      max-width: none;
      margin: 0 auto;
      flex: 0 0 auto;
    }

    .bgremover-preview-wrap[data-preview-bg="dark"] {
      background: radial-gradient(circle at top, #1a2236 0, #05070b 60%);
    }

    .bgremover-preview-wrap[data-preview-bg="light"] {
      background: linear-gradient(180deg, #f4f7ff 0, #e7edf8 100%);
    }

    .bgremover-preview-wrap[data-preview-bg="black"] {
      background: #000;
    }

    .bgremover-preview-controls {
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.06);
      background: rgba(6, 10, 17, 0.88);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .bgremover-slider-row {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .bgremover-slider-row label {
      margin: 0;
      font-size: 0.7rem;
      white-space: nowrap;
    }

    .bgremover-slider-row input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .bgremover-slider-row span {
      font-size: 0.7rem;
      color: var(--muted);
      min-width: 44px;
      text-align: right;
    }

    .bgremover-preview-controls .tiny {
      margin-top: 1px;
    }

    .bgremover-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .bgremover-grid-3 {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
    }

    .bgremover-meta {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .bgremover-hidden {
      display: none !important;
    }

    .bgremover-status {
      min-height: 16px;
    }

    .bgremover-badge-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    #panel-image,
    #panel-watermark,
    #panel-thumbnail {
      grid-column: span 2;
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(300px, 0.92fr);
      gap: 10px 16px;
      align-items: start;
    }

    #panel-image > *,
    #panel-watermark > *,
    #panel-thumbnail > * {
      grid-column: 1;
    }

    #panel-image > .panel-header,
    #panel-watermark > .panel-header,
    #panel-thumbnail > .panel-header {
      grid-column: 1 / -1;
      margin-bottom: 0;
    }

    #panel-image > .tool-live-preview-pane,
    #panel-watermark > .tool-live-preview-pane,
    #panel-thumbnail > .tool-live-preview-pane {
      grid-column: 2;
      grid-row: 2 / span 20;
      position: sticky;
      top: 12px;
    }

    /* Live preview tools get a split workbench layout on larger screens */
    #panel-collage {
      grid-column: span 2;
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(320px, 0.95fr);
      gap: 10px 16px;
      align-items: start;
    }

    #panel-collage > * {
      grid-column: 1;
    }

    #panel-collage > .panel-header {
      grid-column: 1 / -1;
      margin-bottom: 0;
    }

    #panel-collage > .collage-selection-row,
    #panel-collage > #collageCanvas,
    #panel-collage > .collage-preview-note,
    #panel-collage > #collageSlotList,
    #panel-collage > #collageStatus {
      grid-column: 2;
    }

    #panel-collage > #collageCanvas {
      align-self: start;
    }

    #panel-collage > .tiny:last-of-type {
      grid-column: 1 / -1;
    }

    #panel-bgremove {
      grid-column: 1 / -1;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(360px, 0.9fr);
      gap: 10px 18px;
      align-items: start;
    }

    #panel-bgremove > * {
      grid-column: 1;
    }

    #panel-bgremove > .panel-header {
      grid-column: 1 / -1;
      margin-bottom: 0;
    }

    #panel-bgremove > .bgremover-preview-controls,
    #panel-bgremove > .bgremover-preview-wrap,
    #panel-bgremove > .bgremover-meta,
    #panel-bgremove > #bgremoverStatus,
    #panel-bgremove > #bgremoverStatus + .tiny {
      grid-column: 2;
    }

    #panel-bgremove > .bgremover-preview-controls .bgremover-grid-3 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    #panel-bgremove > .bgremover-preview-wrap {
      align-self: start;
    }

    @media (max-width: 1240px) {
      #panel-image,
      #panel-watermark,
      #panel-thumbnail,
      #panel-collage {
        grid-column: 1 / -1;
      }

      #panel-image,
      #panel-watermark,
      #panel-thumbnail,
      #panel-collage,
      #panel-bgremove {
        grid-template-columns: minmax(0, 1fr);
      }

      #panel-image > *,
      #panel-watermark > *,
      #panel-thumbnail > *,
      #panel-collage > *,
      #panel-bgremove > * {
        grid-column: 1 !important;
      }

      #panel-image > .tool-live-preview-pane,
      #panel-watermark > .tool-live-preview-pane,
      #panel-thumbnail > .tool-live-preview-pane {
        grid-row: auto;
        position: static;
      }

      #panel-bgremove > .bgremover-preview-controls .bgremover-grid-3 {
        grid-template-columns: 1fr;
      }

      #panel-collage > .collage-selection-row {
        justify-content: flex-start;
      }

      #panel-collage > .collage-selection-row .tiny {
        text-align: left;
      }

      #panel-bgremove #bgremoverVideoControlsWrap > .bgremover-slider-row:first-child {
        grid-column: 1 !important;
      }
    }

    @keyframes orbit {
      from { transform: rotate(0deg) scale(1); }
      to { transform: rotate(360deg) scale(1); }
    }

    @keyframes orbitGlow {
      0% { box-shadow: 0 0 12px rgba(160, 240, 255, 0.6); }
      50% { box-shadow: 0 0 20px rgba(234, 139, 250, 0.9); }
      100% { box-shadow: 0 0 12px rgba(160, 240, 255, 0.6); }
    }

    /* Extra small mobile tuning */
    @media (max-width: 480px) {
      body {
        align-items: flex-start;
      }
      .app {
        padding: 16px 10px 28px;
      }
      .hero {
        padding: 14px 12px 16px;
        gap: 14px;
      }
      .hero-main-title {
        font-size: 1.45rem;
      }
      .tool-card {
        padding: 12px;
      }
      .panel {
        padding: 12px 12px 14px;
      }
      .workspace {
        padding: 12px;
        gap: 12px;
      }
      input[type="file"],
      input[type="text"],
      input[type="number"],
      input[type="color"],
      select,
      textarea {
        font-size: 0.8rem;
      }
      .btn-small {
        padding: 6px 12px;
      }
      .collage-slot-row {
        grid-template-columns: 1fr;
      }
      .collage-selection-row .tiny {
        text-align: left;
      }
      .bgremover-grid,
      .bgremover-grid-3 {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="brand-mark">
          <div class="brand-mark-inner"></div>
        </div>
        <div class="brand-text">
          <div class="brand-text-title">
            CreatorForge
            <span class="beta-pill">Beta</span>
          </div>
          <div class="brand-text-subtitle">
            Fast, private tools for social media creators
          </div>
        </div>
      </div>
      <div class="header-actions">
        <div class="pill">
          <span class="emoji">üîí</span> On-device. No login. No tracking.
        </div>
        <button class="btn-outline" type="button" onclick="scrollToWorkspace()">
          <span>Open workspace</span> <span>‚Üò</span>
        </button>
      </div>
    </header>

    <section class="hero">
      <div>
        <div class="hero-main-title">
          Create more, <span class="accent">stress less.</span>
        </div>
        <div class="hero-body">
          <strong>CreatorForge</strong> is a lightweight toolbox for resizing images,
          crafting captions, watermarking drafts, checking links, and planning content‚Äî
          all in your browser, with your files staying on your device.
        </div>
        <div class="hero-tags">
          <span class="hero-tag">TikTok ‚Ä¢ Reels ‚Ä¢ Shorts</span>
          <span class="hero-tag">Thumbnails & captions</span>
          <span class="hero-tag">Local-only processing</span>
        </div>
        <div class="hero-footer-note">
          Start by picking a quick tool below, or jump straight into the workspace.
        </div>
      </div>
      <div class="hero-visual">
        <div class="hero-visual-title">Creator flow snapshot</div>
        <div class="hero-visual-main">
          Resize thumbnail ‚Üí add watermark ‚Üí generate caption ‚Üí scan brand link ‚Üí plan post.
        </div>
        <div class="hero-visual-matrix">
          <div class="matrix-chip">
            <span class="matrix-dot"></span> IG 1080√ó1350
          </div>
          <div class="matrix-chip">
            <span class="matrix-dot"></span> Reels 9:16
          </div>
          <div class="matrix-chip">
            <span class="matrix-dot"></span> Safe link check
          </div>
          <div class="matrix-chip">
            <span class="matrix-dot"></span> Hooks & captions
          </div>
          <div class="matrix-chip">
            <span class="matrix-dot"></span> Idea vault
          </div>
          <div class="matrix-chip">
            <span class="matrix-dot"></span> Watermark drafts
          </div>
        </div>
        <div class="hero-visual-orbit"></div>
        <div class="hero-visual-orbit"></div>
        <div class="hero-visual-orbit"></div>
      </div>
    </section>

    <section>
      <div class="section-title">
        <span class="dot"></span>
        Quick tools
      </div>
      <div class="tool-grid">
        <article class="tool-card" onclick="openPanel('image')">
          <div class="tool-header">
            <div class="tool-title">Image Resize & Compress</div>
            <div class="tool-tag">Image</div>
          </div>
          <div class="tool-body">
            Perfect your photos for Reels, Stories, YouTube, and Facebook ‚Äî sized and compressed instantly.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">Presets for IG, Reels, YT, FB</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('image');">
              Open tool ‚Üó
            </button>
          </div>
        </article>

        <article class="tool-card" onclick="openPanel('caption')">
          <div class="tool-header">
            <div class="tool-title">Caption & Hashtag Builder</div>
            <div class="tool-tag">Text</div>
          </div>
          <div class="tool-body">
            Turn your idea into a scroll-stopping caption with platform-ready hashtags for IG, TikTok, YouTube, Facebook, and X.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">Hooks ‚Ä¢ captions ‚Ä¢ tags</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('caption');">
              Open tool ‚Üó
            </button>
          </div>
        </article>

        <article class="tool-card" onclick="openPanel('link')">
          <div class="tool-header">
            <div class="tool-title">Safe Link Scan</div>
            <div class="tool-tag">Safety</div>
          </div>
          <div class="tool-body">
            Check brand collab links, sponsorship URLs, or giveaway pages for quick red flags before you click.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">No network calls, heuristics only</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('link');">
              Open tool ‚Üó
            </button>
          </div>
        </article>

        <article class="tool-card" onclick="openPanel('planner')">
          <div class="tool-header">
            <div class="tool-title">Content Planner</div>
            <div class="tool-tag">Planning</div>
          </div>
          <div class="tool-body">
            Organize your video ideas, photo concepts, and posting schedule in a clean, creator-friendly planner.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">Saved to this browser only</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('planner');">
              Open tool ‚Üó
            </button>
          </div>
        </article>

        <article class="tool-card" onclick="openPanel('watermark')">
          <div class="tool-header">
            <div class="tool-title">Watermark Helper</div>
            <div class="tool-tag">Image</div>
          </div>
          <div class="tool-body">
            Tag your drafts with your @handle before sending them to brands, editors, or collaborators.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">Overlay text on your image</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('watermark');">
              Open tool ‚Üó
            </button>
          </div>
        </article>

        <article class="tool-card" onclick="openPanel('thumbnail')">
          <div class="tool-header">
            <div class="tool-title">Thumbnail Starter</div>
            <div class="tool-tag">Image</div>
          </div>
          <div class="tool-body">
            Create bold text-first thumbnails for YouTube videos, Shorts, Reels covers, and Story promos.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">Text-first layouts</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('thumbnail');">
              Open tool ‚Üó
            </button>
          </div>
        </article>

        <article class="tool-card" onclick="openPanel('collage')">
          <div class="tool-header">
            <div class="tool-title">Photo & Video Collage Maker</div>
            <div class="tool-tag">Collage</div>
          </div>
          <div class="tool-body">
            Build Canva-style collages with live preview, draggable media positioning, and multiple export sizes.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">Photos + videos ‚Ä¢ drag to frame</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('collage');">
              Open tool ‚Üó
            </button>
          </div>
        </article>
        <article class="tool-card" onclick="openPanel('bgremove')">
          <div class="tool-header">
            <div class="tool-title">Background Remover (Photo + Video)</div>
            <div class="tool-tag">AI / Chroma</div>
          </div>
          <div class="tool-body">
            Remove backgrounds with AI subject cutout or green-screen keying, then export transparent or chroma-green outputs.
          </div>
          <div class="tool-bottom">
            <div class="tool-meta">Transparent PNG + WebM preview/export</div>
            <button class="btn-small" type="button" onclick="event.stopPropagation(); openPanel('bgremove');">
              Open tool
            </button>
          </div>
        </article>
      </div>
    </section>

    <section id="workspace">
      <div class="section-title">
        <span class="dot"></span>
        Creator workspace
      </div>
      <div class="workspace">
        <!-- Image Resize Panel -->
        <div class="panel" id="panel-image">
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">üñº</span> Image Resize & Compress
            </div>
            <div class="panel-header-right">
              <span class="badge">Live preview</span>
              <span class="badge">On-device</span>
              <span class="hint" title="Resize and compress photos for IG, Reels, Stories, YouTube, and Facebook.">?</span>
            </div>
          </div>

          <div>
            <label for="imageInput">Upload image</label>
            <input type="file" id="imageInput" accept="image/*" />
          </div>

          <div>
            <label>Preset</label>
            <div class="inline-controls">
              <button class="chip" type="button" data-size="1080x1080"
                onclick="setPreset(this)">IG Post</button>
              <button class="chip" type="button" data-size="1080x1350"
                onclick="setPreset(this)">IG Portrait</button>
              <button class="chip" type="button" data-size="1080x1920"
                onclick="setPreset(this)">Reel / Story</button>
              <button class="chip" type="button" data-size="1280x720"
                onclick="setPreset(this)">YT Thumb</button>
              <button class="chip" type="button" data-size="1200x630"
                onclick="setPreset(this)">FB Post</button>
            </div>
          </div>

          <div class="inline-controls">
            <div style="flex:1">
              <label for="widthInput">Width</label>
              <input type="number" id="widthInput" placeholder="auto" min="1" />
            </div>
            <div style="flex:1">
              <label for="heightInput">Height</label>
              <input type="number" id="heightInput" placeholder="auto" min="1" />
            </div>
          </div>

          <div class="inline-controls">
            <div>
              <input type="checkbox" id="keepRatio" checked />
              <label for="keepRatio">Keep aspect ratio</label>
            </div>
            <div>
              <label for="qualityInput">Quality (JPEG)</label>
              <input type="number" id="qualityInput" min="10" max="100"
                value="85" style="width:70px" />
            </div>
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" onclick="resizeImage()">
              Process image
            </button>
            <button class="btn-small" type="button" id="downloadImageBtn"
              onclick="downloadResizedImage()" disabled>
              Download result
            </button>
          </div>

          <div class="tiny">
            Files are processed in this browser only. For best results, start
            from the highest quality original you have.
          </div>

          <div class="tool-live-preview-pane">
            <div class="tool-live-preview-meta">
              <span class="badge">Resize preview</span>
              <span class="tiny" id="imagePreviewMeta">No image loaded</span>
            </div>
            <div class="tool-live-preview-frame-row">
              <label for="imagePreviewFrameMode">Preview frame</label>
              <select id="imagePreviewFrameMode">
                <option value="auto" selected>Auto</option>
                <option value="portrait">Portrait</option>
                <option value="landscape">Landscape</option>
                <option value="square">Square</option>
              </select>
            </div>
            <div class="tool-live-preview-window" id="imagePreviewWindow" data-preview-frame="auto">
              <div class="tool-live-preview-empty" id="imagePreviewEmpty">
                Upload an image to see a live resized preview here.
              </div>
              <canvas id="imageCanvas" class="canvas-preview" style="display:none;"></canvas>
            </div>
            <div class="tiny tool-live-preview-status" id="imagePreviewStatus">
              Preview updates as you change width/height.
            </div>
            <div class="tool-live-preview-note">
              The preview uses the processed output canvas. JPEG quality primarily affects download compression, not preview sharpness.
            </div>
          </div>
        </div>

        <!-- Caption Builder Panel -->
        <div class="panel" id="panel-caption">
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">‚úçÔ∏è</span> Caption & Hashtag Builder
            </div>
            <div class="panel-header-right">
              <span class="badge">Local helper</span>
              <span class="hint" title="Turn your post idea into a caption with suggested hooks and hashtags for each platform.">?</span>
            </div>
          </div>

          <div>
            <label for="captionTopic">What is your post about?</label>
            <input type="text" id="captionTopic"
              placeholder="Example: Behind the scenes of my small business packaging day" />
          </div>

          <div class="inline-controls">
            <div style="flex:1">
              <label for="captionTone">Tone</label>
              <select id="captionTone">
                <option value="friendly">Friendly & casual</option>
                <option value="educational">Educational & clear</option>
                <option value="hype">Hype / high energy</option>
                <option value="aesthetic">Aesthetic / minimal</option>
              </select>
            </div>
            <div style="flex:1">
              <label for="captionPlatform">Platform</label>
              <select id="captionPlatform">
                <option value="instagram">Instagram</option>
                <option value="tiktok">TikTok</option>
                <option value="youtube">YouTube</option>
                <option value="facebook">Facebook</option>
                <option value="twitter">X / Twitter</option>
              </select>
            </div>
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" onclick="generateCaption()">
              Generate caption
            </button>
            <button class="btn-small" type="button" onclick="copyCaption()">
              Copy to clipboard
            </button>
          </div>

          <div class="result-box" id="captionResult">
            Your generated caption will appear here.
          </div>
          <div class="tiny" id="captionStatus"></div>

          <div class="tiny">
            This is a starter caption builder‚Äîfeel free to tweak the wording so
            it sounds exactly like you.
          </div>
        </div>

        <!-- Safe Link & Planner (stacked) -->
        <div class="panel" id="panel-link-planner">
          <!-- Safe Link -->
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">üõ°</span> Safe Link Scan
            </div>
            <div class="panel-header-right">
              <span class="badge">Heuristics only</span>
              <span class="hint" title="Check structure of brand links, sponsorship URLs, or giveaway pages for common red flags.">?</span>
            </div>
          </div>

          <div>
            <label for="linkInput">Paste a link to scan</label>
            <input type="text" id="linkInput"
              placeholder="Example: https://brand-offer.example.com/collab" />
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" onclick="scanLink()">
              Run checks
            </button>
          </div>

          <div class="result-box" id="linkResult">
            We‚Äôll check for HTTPS, suspicious patterns, and unusual domains. This
            does not contact the URL or guarantee safety.
          </div>

          <!-- Divider -->
          <div style="margin:8px 0;border-bottom:1px dashed rgba(255,255,255,0.06);"></div>

          <!-- Content Planner -->
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">üìÖ</span> Mini Content Planner
            </div>
            <div class="panel-header-right">
              <span class="badge">Saved here only</span>
              <span class="hint" title="Track post ideas, platforms, and rough timing for your upcoming content.">?</span>
            </div>
          </div>

          <div class="inline-controls">
            <input type="text" id="plannerTitle"
              placeholder="Example: GRWM morning routine reel" />
          </div>
          <div class="inline-controls">
            <select id="plannerPlatform" style="flex:1">
              <option value="">Platform</option>
              <option>Instagram</option>
              <option>TikTok</option>
              <option>YouTube</option>
              <option>Facebook</option>
              <option>X / Twitter</option>
            </select>
            <input type="text" id="plannerWhen" style="flex:1"
              placeholder="When? (e.g. Sun morning or 7pm)" />
          </div>
          <div class="inline-controls">
            <button class="btn-small" type="button" onclick="addPlanItem()">
              Add to planner
            </button>
            <button class="btn-small" type="button" onclick="clearPlanner()">
              Clear all
            </button>
          </div>

          <ul class="planner-list" id="plannerList"></ul>
        </div>

        <!-- Watermark Panel -->
        <div class="panel" id="panel-watermark">
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">üìù</span> Watermark Helper
            </div>
            <div class="panel-header-right">
              <span class="badge">Live preview</span>
              <span class="badge">On-device</span>
              <span class="hint" title="Overlay your @handle or brand name as text on top of your image before sharing.">?</span>
            </div>
          </div>

          <div>
            <label for="wmImageInput">Upload image to watermark</label>
            <input type="file" id="wmImageInput" accept="image/*" />
          </div>

          <div>
            <label for="watermarkText">Watermark text (e.g. @yourhandle)</label>
            <input type="text" id="watermarkText"
              placeholder="@yourhandle or brand name" />
          </div>

          <div class="inline-controls">
            <div style="flex:1">
              <label for="watermarkPosition">Position</label>
              <select id="watermarkPosition">
                <option value="bottom-right">Bottom right</option>
                <option value="bottom-left">Bottom left</option>
                <option value="top-right">Top right</option>
                <option value="top-left">Top left</option>
                <option value="center">Center</option>
              </select>
            </div>
            <div style="flex:1">
              <label for="watermarkColor">Color</label>
              <input type="color" id="watermarkColor" value="#ffffff" />
            </div>
          </div>

          <div class="range-row">
            <label style="margin:0;">Size</label>
            <input type="range" id="watermarkSize" min="16" max="72" value="32" />
            <span id="watermarkSizeLabel">32px</span>
          </div>

          <div class="range-row">
            <label style="margin:0;">Opacity</label>
            <input type="range" id="watermarkOpacity" min="20" max="100" value="70" />
            <span id="watermarkOpacityLabel">70%</span>
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" onclick="previewWatermark()">
              Preview watermark
            </button>
            <button class="btn-small" type="button" id="downloadWatermarkBtn"
              onclick="downloadWatermarkedImage()" disabled>
              Download watermarked
            </button>
          </div>

          <div class="tiny">
            This tool overlays text only (no image logos yet). Great for quick
            protection before sending files for review.
          </div>

          <div class="tool-live-preview-pane">
            <div class="tool-live-preview-meta">
              <span class="badge">Watermark preview</span>
              <span class="tiny" id="wmPreviewMeta">No image loaded</span>
            </div>
            <div class="tool-live-preview-frame-row">
              <label for="wmPreviewFrameMode">Preview frame</label>
              <select id="wmPreviewFrameMode">
                <option value="auto" selected>Auto</option>
                <option value="portrait">Portrait</option>
                <option value="landscape">Landscape</option>
                <option value="square">Square</option>
              </select>
            </div>
            <div class="tool-live-preview-window" id="wmPreviewWindow" data-preview-frame="auto">
              <div class="tool-live-preview-empty" id="wmPreviewEmpty">
                Upload an image and type watermark text to preview placement in real time.
              </div>
              <canvas id="watermarkCanvas" class="canvas-preview" style="display:none;"></canvas>
            </div>
            <div class="tiny tool-live-preview-status" id="wmPreviewStatus">
              Live preview updates while you edit text, position, size, color, and opacity.
            </div>
            <div class="tool-live-preview-note">
              Downloads remain disabled until watermark text is present, but the base image will preview immediately after upload.
            </div>
          </div>
        </div>

        <!-- Thumbnail Starter Panel -->
        <div class="panel" id="panel-thumbnail">
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">üé¨</span> Thumbnail Starter
            </div>
            <div class="panel-header-right">
              <span class="badge">Live preview</span>
              <span class="badge">Text-first</span>
              <span class="hint" title="Generate simple, bold text layouts for thumbnails and covers you can layer with your photos.">?</span>
            </div>
          </div>

          <div>
            <label for="thumbTitle">Main title text</label>
            <input type="text" id="thumbTitle"
              placeholder="Example: 5 Outfit Ideas for Fall" />
          </div>

          <div>
            <label for="thumbSubtitle">Optional subtitle</label>
            <input type="text" id="thumbSubtitle"
              placeholder="Easy looks anyone can try" />
          </div>

          <div class="inline-controls">
            <div style="flex:1">
              <label for="thumbPreset">Preset size</label>
              <select id="thumbPreset">
                <option value="1280x720">YouTube (1280√ó720)</option>
                <option value="1080x1920">Vertical (1080√ó1920)</option>
                <option value="1080x1080">Square (1080√ó1080)</option>
              </select>
            </div>
            <div style="flex:1">
              <label for="thumbLayout">Layout</label>
              <select id="thumbLayout">
                <option value="center">Center</option>
                <option value="bottom">Bottom band</option>
                <option value="left">Left stack</option>
              </select>
            </div>
          </div>

          <div class="inline-controls">
            <div style="flex:1">
              <label for="thumbStyle">Background style</label>
              <select id="thumbStyle">
                <option value="dark">Deep dark</option>
                <option value="neon">Neon gradient</option>
                <option value="soft">Soft pastel</option>
              </select>
            </div>
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" onclick="generateThumbnail()">
              Generate thumbnail
            </button>
            <button class="btn-small" type="button" id="downloadThumbBtn"
              onclick="downloadThumbnail()" disabled>
              Download PNG
            </button>
          </div>

          <div class="tiny">
            This is a simple text-based layout starter. You can layer this under
            your photos or use as-is for clean, bold titles.
          </div>

          <div class="tool-live-preview-pane">
            <div class="tool-live-preview-meta">
              <span class="badge">Thumbnail preview</span>
              <span class="tiny" id="thumbPreviewMeta">No thumbnail generated</span>
            </div>
            <div class="tool-live-preview-frame-row">
              <label for="thumbPreviewFrameMode">Preview frame</label>
              <select id="thumbPreviewFrameMode">
                <option value="auto" selected>Auto</option>
                <option value="portrait">Portrait</option>
                <option value="landscape">Landscape</option>
                <option value="square">Square</option>
              </select>
            </div>
            <div class="tool-live-preview-window" id="thumbPreviewWindow" data-preview-frame="auto">
              <div class="tool-live-preview-empty" id="thumbPreviewEmpty">
                Type a main title to generate a live thumbnail preview.
              </div>
              <canvas id="thumbCanvas" class="canvas-preview" style="display:none;"></canvas>
            </div>
            <div class="tiny tool-live-preview-status" id="thumbPreviewStatus">
              Preview updates while you change title, layout, size, and style.
            </div>
            <div class="tool-live-preview-note">
              The live preview uses the same canvas that downloads as PNG.
            </div>
          </div>
        </div>

        <!-- Photo & Video Collage Maker -->
        <div class="panel" id="panel-collage">
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">üß©</span> Photo & Video Collage Maker
            </div>
            <div class="panel-header-right">
              <span class="badge">Live preview</span>
              <span class="hint" title="Canva-style collage workflow: upload photos/videos, drag within each tile, and export PNG or WebM.">?</span>
            </div>
          </div>

          <div>
            <label for="collageMediaInput">Upload photos/videos (up to 8)</label>
            <input type="file" id="collageMediaInput" accept="image/*,video/*" multiple />
          </div>

          <div class="inline-controls">
            <div style="flex:1">
              <label for="collagePreset">Collage size + layout</label>
              <select id="collagePreset">
                <option value="square-duo">Square Duo (1080√ó1080)</option>
                <option value="square-grid4">Square Grid 4 (1080√ó1080)</option>
                <option value="portrait-feature" selected>Portrait Feature 3 (1080√ó1350)</option>
                <option value="story-split3">Story Split 3 (1080√ó1920)</option>
                <option value="story-grid4">Vertical Grid 4 (1080√ó1920)</option>
                <option value="widescreen-feature">Widescreen Feature 3 (1920√ó1080)</option>
              </select>
            </div>
            <div style="width:92px">
              <label for="collageBg">Background</label>
              <input type="color" id="collageBg" value="#0b1020" />
            </div>
          </div>

          <div class="range-row">
            <label style="margin:0;" for="collageGap">Gap</label>
            <input type="range" id="collageGap" min="0" max="40" value="12" />
            <span id="collageGapLabel">12px</span>
          </div>

          <div class="range-row">
            <label style="margin:0;" for="collageRadius">Corners</label>
            <input type="range" id="collageRadius" min="0" max="40" value="14" />
            <span id="collageRadiusLabel">14px</span>
          </div>

          <div class="range-row">
            <label style="margin:0;" for="collageZoom">Zoom tile</label>
            <input type="range" id="collageZoom" min="100" max="240" value="100" />
            <span id="collageZoomLabel">100%</span>
          </div>

          <div class="inline-controls collage-selection-row">
            <span class="badge" id="collageSelectedTileBadge">Tile: none</span>
            <span class="tiny" id="collageSelectedMediaLabel">Select a tile in the preview, then drag to reposition.</span>
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" id="collagePlaybackBtn" onclick="toggleCollagePlayback()">
              Play videos
            </button>
            <button class="btn-small" type="button" onclick="resetCollageSelectedTile()">
              Reset tile
            </button>
            <button class="btn-small" type="button" id="downloadCollagePngBtn" onclick="downloadCollagePng()" disabled>
              Download PNG
            </button>
          </div>

          <div class="inline-controls">
            <div style="flex:1">
              <label for="collageExportSeconds">WebM export length (video collages)</label>
              <input type="number" id="collageExportSeconds" min="1" max="30" value="6" />
            </div>
            <button class="btn-small" type="button" id="downloadCollageVideoBtn" onclick="exportCollageVideo()" disabled>
              Export WebM
            </button>
          </div>

          <canvas id="collageCanvas" class="canvas-preview collage-canvas" width="1080" height="1350"></canvas>

          <div class="collage-preview-note">
            Live preview uses the same canvas composition that powers PNG/WebM export. Tap or click a tile to select it, then drag to slide media inside the frame.
          </div>

          <div class="collage-slot-list" id="collageSlotList"></div>

          <div class="tiny collage-status" id="collageStatus">Upload photos or videos to start a collage.</div>
          <div class="tiny">
            Video export is WebM and records the collage canvas without audio (keeps this tool fully in-browser).
          </div>
        </div>

        <!-- Background Remover (Photo + Video) -->
        <div class="panel" id="panel-bgremove">
          <div class="panel-header">
            <div class="panel-title">
              <span class="emoji">‚úÇÔ∏è</span> Background Remover (Photo + Video)
            </div>
            <div class="panel-header-right">
              <span class="badge">AI + Chroma</span>
              <span class="hint" title="AI subject cutout for people/products and manual chroma key controls for green-screen footage.">?</span>
            </div>
          </div>

          <div>
            <label for="bgremoverInput">Upload a photo or video</label>
            <input type="file" id="bgremoverInput" accept="image/*,video/*" />
          </div>

          <div class="bgremover-grid">
            <div>
              <label for="bgremoverEngine">Removal mode</label>
              <select id="bgremoverEngine">
                <option value="ai" selected>AI subject cutout (best for people)</option>
                <option value="chroma">Green screen key (manual)</option>
              </select>
            </div>
            <div>
              <label for="bgremoverOutputMode">Output background</label>
              <select id="bgremoverOutputMode">
                <option value="transparent" selected>Transparent</option>
                <option value="green">Chroma green</option>
                <option value="custom">Custom color</option>
              </select>
            </div>
          </div>

          <div class="bgremover-grid-3">
            <div>
              <label for="bgremoverModel">AI model</label>
              <select id="bgremoverModel">
                <option value="1" selected>General (quality)</option>
                <option value="0">Landscape (faster)</option>
              </select>
            </div>
            <div>
              <label for="bgremoverMaxDim">Max processing size</label>
              <input type="number" id="bgremoverMaxDim" min="256" max="1920" step="32" value="960" />
            </div>
            <div id="bgremoverCustomColorWrap">
              <label for="bgremoverCustomColor">Custom BG</label>
              <input type="color" id="bgremoverCustomColor" value="#101a2a" />
            </div>
          </div>

          <div class="range-row">
            <label style="margin:0;" for="bgremoverThreshold">Threshold</label>
            <input type="range" id="bgremoverThreshold" min="1" max="99" value="46" />
            <span id="bgremoverThresholdLabel">46%</span>
          </div>

          <div class="range-row">
            <label style="margin:0;" for="bgremoverSoftness">Softness</label>
            <input type="range" id="bgremoverSoftness" min="0" max="50" value="12" />
            <span id="bgremoverSoftnessLabel">12%</span>
          </div>

          <div class="range-row">
            <label style="margin:0;" for="bgremoverFeather">Feather</label>
            <input type="range" id="bgremoverFeather" min="0" max="12" value="2" />
            <span id="bgremoverFeatherLabel">2px</span>
          </div>

          <div class="range-row">
            <label style="margin:0;" for="bgremoverDespill">Despill</label>
            <input type="range" id="bgremoverDespill" min="0" max="100" value="35" />
            <span id="bgremoverDespillLabel">35%</span>
          </div>

          <div class="bgremover-grid-3">
            <div>
              <label for="bgremoverHueCenter">Key hue (chroma)</label>
              <input type="number" id="bgremoverHueCenter" min="0" max="360" step="1" value="120" />
            </div>
            <div>
              <label for="bgremoverHueWidth">Hue width</label>
              <input type="number" id="bgremoverHueWidth" min="1" max="180" step="1" value="55" />
            </div>
            <div>
              <label for="bgremoverSatMin">Min saturation</label>
              <input type="number" id="bgremoverSatMin" min="0" max="100" step="1" value="20" />
            </div>
          </div>

          <div class="bgremover-grid">
            <div>
              <label for="bgremoverValMin">Min brightness (chroma)</label>
              <input type="number" id="bgremoverValMin" min="0" max="100" step="1" value="8" />
            </div>
            <div>
              <label for="bgremoverExportSeconds">WebM export length</label>
              <input type="number" id="bgremoverExportSeconds" min="1" max="20" step="1" value="6" />
            </div>
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" id="bgremoverRefreshBtn">Refresh preview</button>
            <button class="btn-small" type="button" id="bgremoverPlayBtn" disabled>Play video</button>
            <button class="btn-small" type="button" id="bgremoverResetBtn">Reset settings</button>
            <button class="btn-small" type="button" id="bgremoverClearBtn">Clear media</button>
          </div>

          <div class="inline-controls">
            <button class="btn-small" type="button" id="bgremoverDownloadImageBtn" disabled>Download PNG</button>
            <button class="btn-small" type="button" id="bgremoverExportVideoBtn" disabled>Export WebM</button>
          </div>

          <div class="bgremover-preview-controls">
            <div class="bgremover-grid-3">
              <div>
                <label for="bgremoverPreviewMode">Preview mode</label>
                <select id="bgremoverPreviewMode">
                  <option value="result">Processed only</option>
                  <option value="split" selected>Before / after split</option>
                  <option value="side">Side by side</option>
                </select>
              </div>
              <div>
                <label for="bgremoverPreviewBg">Preview background</label>
                <select id="bgremoverPreviewBg">
                  <option value="checker" selected>Checkerboard</option>
                  <option value="dark">Dark</option>
                  <option value="light">Light</option>
                  <option value="black">Black</option>
                </select>
              </div>
              <div>
                <label for="bgremoverPreviewZoom">Preview zoom</label>
                <div class="bgremover-slider-row">
                  <label for="bgremoverPreviewZoom" class="bgremover-hidden">Zoom</label>
                  <input type="range" id="bgremoverPreviewZoom" min="50" max="220" value="100" />
                  <span id="bgremoverPreviewZoomLabel">100%</span>
                </div>
              </div>
            </div>

            <div class="bgremover-slider-row" id="bgremoverPreviewSplitWrap">
              <label for="bgremoverPreviewSplit">Split</label>
              <input type="range" id="bgremoverPreviewSplit" min="0" max="100" value="50" />
              <span id="bgremoverPreviewSplitLabel">50%</span>
            </div>

            <div class="bgremover-grid-3">
              <div class="bgremover-slider-row">
                <label for="bgremoverSubjectScale">Subject</label>
                <input type="range" id="bgremoverSubjectScale" min="70" max="140" value="100" />
                <span id="bgremoverSubjectScaleLabel">100%</span>
              </div>
              <div class="bgremover-slider-row">
                <label for="bgremoverOffsetX">Offset X</label>
                <input type="range" id="bgremoverOffsetX" min="-40" max="40" value="0" />
                <span id="bgremoverOffsetXLabel">0%</span>
              </div>
              <div class="bgremover-slider-row">
                <label for="bgremoverOffsetY">Offset Y</label>
                <input type="range" id="bgremoverOffsetY" min="-40" max="40" value="0" />
                <span id="bgremoverOffsetYLabel">0%</span>
              </div>
            </div>

            <div class="bgremover-grid-3" id="bgremoverVideoControlsWrap">
              <div class="bgremover-slider-row" style="grid-column: span 2;">
                <label for="bgremoverVideoSeek">Scrub</label>
                <input type="range" id="bgremoverVideoSeek" min="0" max="1000" value="0" />
                <span id="bgremoverVideoSeekLabel">0:00</span>
              </div>
              <div class="bgremover-slider-row">
                <label for="bgremoverPlaybackRate">Speed</label>
                <input type="range" id="bgremoverPlaybackRate" min="25" max="200" value="100" />
                <span id="bgremoverPlaybackRateLabel">1.00x</span>
              </div>
            </div>

            <div class="tiny">
              Live preview compare/framing controls are visual-only and do not change your exported PNG/WebM output.
            </div>
          </div>

          <div class="bgremover-preview-wrap" id="bgremoverPreviewWrap" data-preview-bg="checker">
            <canvas id="bgremoverLivePreviewCanvas" class="bgremover-live-preview-canvas" width="960" height="540"></canvas>
          </div>

          <div class="bgremover-meta">
            <div class="bgremover-badge-row">
              <span class="badge" id="bgremoverSourceBadge">No media loaded</span>
              <span class="badge" id="bgremoverEngineBadge">AI mode</span>
            </div>
            <div class="tiny" id="bgremoverDimensionsLabel">Preview: --</div>
          </div>

          <div class="tiny bgremover-status" id="bgremoverStatus">Upload a photo or video to start background removal.</div>
          <div class="tiny">
            AI mode uses an in-browser segmentation model (best for people/portraits). Chroma mode is for green-screen footage. Transparent PNG export works for photos; transparent WebM support depends on the browser codec and is treated as beta.
          </div>

          <canvas id="bgremoverCanvas" class="bgremover-hidden" width="960" height="540"></canvas>
          <video id="bgremoverSourceVideo" playsinline muted loop class="bgremover-hidden"></video>
          <canvas id="bgremoverSourceCanvas" class="bgremover-hidden"></canvas>
          <canvas id="bgremoverMaskCanvas" class="bgremover-hidden"></canvas>
          <canvas id="bgremoverFeatherCanvas" class="bgremover-hidden"></canvas>
        </div>
      </div>

      <div class="footer-note">
        This is an early prototype of CreatorForge. Features will evolve as we
        learn from real creators.
      </div>
    </section>
  </div>

  <script>
    function scrollToWorkspace() {
      const el = document.getElementById('workspace');
      if (!el) return;
      el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    function openPanel(kind) {
      scrollToWorkspace();
      const panelId =
        kind === 'image' ? 'panel-image'
        : kind === 'caption' ? 'panel-caption'
        : kind === 'link' ? 'panel-link-planner'
        : kind === 'planner' ? 'panel-link-planner'
        : kind === 'watermark' ? 'panel-watermark'
        : kind === 'thumbnail' ? 'panel-thumbnail'
        : kind === 'collage' ? 'panel-collage'
        : kind === 'bgremove' ? 'panel-bgremove'
        : null;

      if (!panelId) return;

      const panel = document.getElementById(panelId);
      if (panel) {
        panel.style.boxShadow = '0 0 0 1px rgba(160,240,255,0.85)';
        panel.style.transition = 'box-shadow 0.3s ease';
        setTimeout(() => {
          panel.style.boxShadow = 'none';
        }, 700);
      }
    }

    function bindPreviewFrameMode(selectId, previewWindowId) {
      const select = document.getElementById(selectId);
      const previewWindow = document.getElementById(previewWindowId);
      if (!select || !previewWindow) return;

      const allowed = new Set(['auto', 'portrait', 'landscape', 'square']);
      const apply = () => {
        const value = allowed.has(select.value) ? select.value : 'auto';
        previewWindow.setAttribute('data-preview-frame', value);
      };

      select.addEventListener('change', apply);
      apply();
    }

    bindPreviewFrameMode('imagePreviewFrameMode', 'imagePreviewWindow');
    bindPreviewFrameMode('wmPreviewFrameMode', 'wmPreviewWindow');
    bindPreviewFrameMode('thumbPreviewFrameMode', 'thumbPreviewWindow');

    /* ---------- Image Resize & Compress ---------- */
    let loadedImage = null;
    let resizedBlob = null;
    let originalAspect = null;

    const imageInput = document.getElementById('imageInput');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const keepRatioCheckbox = document.getElementById('keepRatio');
    const qualityInput = document.getElementById('qualityInput');
    const imageCanvas = document.getElementById('imageCanvas');
    const downloadBtn = document.getElementById('downloadImageBtn');
    const imagePreviewEmpty = document.getElementById('imagePreviewEmpty');
    const imagePreviewMeta = document.getElementById('imagePreviewMeta');
    const imagePreviewStatus = document.getElementById('imagePreviewStatus');

    function setImageResizePreviewVisible(show) {
      if (imageCanvas) imageCanvas.style.display = show ? 'block' : 'none';
      if (imagePreviewEmpty) imagePreviewEmpty.style.display = show ? 'none' : 'block';
    }

    function setImageResizePreviewMeta(text) {
      if (imagePreviewMeta) imagePreviewMeta.textContent = text;
    }

    function setImageResizePreviewStatus(text) {
      if (imagePreviewStatus) imagePreviewStatus.textContent = text;
    }

    function renderImageResizePreview(options = {}) {
      const generateBlob = !!options.generateBlob;
      const silent = !!options.silent;

      if (!loadedImage || !imageCanvas) {
        if (!silent) alert('Please upload an image first.');
        setImageResizePreviewVisible(false);
        setImageResizePreviewMeta('No image loaded');
        setImageResizePreviewStatus('Upload an image to start the live preview.');
        return false;
      }

      let targetW = parseInt(widthInput?.value, 10);
      let targetH = parseInt(heightInput?.value, 10);

      if (!targetW && !targetH) {
        targetW = loadedImage.width;
        targetH = loadedImage.height;
      } else if (!targetW) {
        targetW = Math.round(targetH * originalAspect);
      } else if (!targetH) {
        targetH = Math.round(targetW / originalAspect);
      }

      if (!targetW || !targetH || targetW <= 0 || targetH <= 0) {
        if (!silent) alert('Please set a valid width and/or height.');
        return false;
      }

      const canvas = imageCanvas;
      const ctx = canvas.getContext('2d');
      canvas.width = targetW;
      canvas.height = targetH;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(loadedImage, 0, 0, targetW, targetH);

      setImageResizePreviewVisible(true);
      setImageResizePreviewMeta(`${loadedImage.width}x${loadedImage.height} -> ${targetW}x${targetH}`);

      let quality = parseInt(qualityInput?.value, 10);
      if (!quality || quality < 10) quality = 10;
      if (quality > 100) quality = 100;

      if (!generateBlob) {
        resizedBlob = null;
        if (downloadBtn) downloadBtn.disabled = true;
        setImageResizePreviewStatus(`Live preview updated (${targetW} x ${targetH}). Click Process image to regenerate download.`);
        return true;
      }

      const q = quality / 100;
      canvas.toBlob(
        blob => {
          if (!blob) {
            alert('Something went wrong generating the image.');
            return;
          }
          resizedBlob = blob;
          if (downloadBtn) downloadBtn.disabled = false;
          setImageResizePreviewStatus(`Processed ${targetW} x ${targetH} JPEG at ${quality}% quality. Ready to download.`);
        },
        'image/jpeg',
        q
      );
      return true;
    }

    function queueImageResizeLivePreview() {
      renderImageResizePreview({ silent: true, generateBlob: false });
    }

    if (imageInput) {
      imageInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            loadedImage = img;
            originalAspect = img.width / img.height;
            if (!widthInput.value && !heightInput.value) {
              widthInput.value = img.width;
              heightInput.value = img.height;
            }
            resizedBlob = null;
            downloadBtn.disabled = true;
            queueImageResizeLivePreview();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    function setPreset(button) {
      const size = button.getAttribute('data-size');
      if (!size) return;
      const [w, h] = size.split('x').map(Number);
      widthInput.value = w || '';
      heightInput.value = h || '';
      document.querySelectorAll('.chip').forEach(chip => chip.classList.remove('active'));
      button.classList.add('active');
      queueImageResizeLivePreview();
    }

    widthInput?.addEventListener('input', () => {
      if (!keepRatioCheckbox.checked || !originalAspect) {
        queueImageResizeLivePreview();
        return;
      }
      const w = parseInt(widthInput.value, 10);
      if (!w || w <= 0) {
        queueImageResizeLivePreview();
        return;
      }
      const newH = Math.round(w / originalAspect);
      heightInput.value = newH;
      queueImageResizeLivePreview();
    });

    heightInput?.addEventListener('input', () => {
      if (!keepRatioCheckbox.checked || !originalAspect) {
        queueImageResizeLivePreview();
        return;
      }
      const h = parseInt(heightInput.value, 10);
      if (!h || h <= 0) {
        queueImageResizeLivePreview();
        return;
      }
      const newW = Math.round(h * originalAspect);
      widthInput.value = newW;
      queueImageResizeLivePreview();
    });

    widthInput?.addEventListener('change', queueImageResizeLivePreview);
    heightInput?.addEventListener('change', queueImageResizeLivePreview);
    qualityInput?.addEventListener('input', queueImageResizeLivePreview);
    keepRatioCheckbox?.addEventListener('change', queueImageResizeLivePreview);

    function resizeImage() {
      renderImageResizePreview({ generateBlob: true, silent: false });
    }

    function downloadResizedImage() {
      if (!resizedBlob) {
        alert('No processed image yet. Run "Process image" first.');
        return;
      }
      const url = URL.createObjectURL(resizedBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'creatorforge-image.jpg';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* ---------- Caption Builder (with Facebook) ---------- */
    function generateCaption() {
      const topic = (document.getElementById('captionTopic')?.value || '').trim();
      const tone = document.getElementById('captionTone')?.value || 'friendly';
      const platform = document.getElementById('captionPlatform')?.value || 'instagram';
      const outEl = document.getElementById('captionResult');
      const statusEl = document.getElementById('captionStatus');

      if (!topic) {
        outEl.textContent = 'Describe what your post is about first.';
        if (statusEl) statusEl.textContent = '';
        return;
      }

      const hooks = {
        friendly: [
          `You won't believe how easy this is üëÄ`,
          `Sharing this because it helped me so much üí°`,
          `If you needed this today, you‚Äôre not alone üíõ`,
        ],
        educational: [
          `Here‚Äôs a simple breakdown you can save for later üìå`,
          `Most people get this wrong‚Äîhere‚Äôs the fix üß†`,
          `Step-by-step so you never have to guess again ‚úÖ`,
        ],
        hype: [
          `This might be my favorite thing I‚Äôve shared yet ü§Ø`,
          `We‚Äôre leveling up today‚Äîlet‚Äôs gooo ‚ö°`,
          `I dare you to try this and NOT be amazed üò§`,
        ],
        aesthetic: [
          `Little things that make life feel softer üå´`,
          `Saving this moment here üïä`,
          `Details you might miss at first glance ‚ú®`,
        ],
      };

      const tagSets = {
        instagram: ['#instagram', '#creator', '#reels', '#contentcreator'],
        tiktok: ['#tiktok', '#fyp', '#tiktoktips', '#contentcreator'],
        youtube: ['#youtube', '#youtubeshorts', '#contentcreator', '#learnontiktok'],
        facebook: ['#facebook', '#creators', '#socialmedia', '#contentcreator'],
        twitter: ['#buildinpublic', '#creators', '#tech', '#workflow'],
      };

      const chosenHooks = hooks[tone] || hooks.friendly;
      const hook = chosenHooks[Math.floor(Math.random() * chosenHooks.length)];

      const baseTags = tagSets[platform] || tagSets.instagram;
      const topicTag = '#' + topic
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '')
        .slice(0, 20);

      const captionLines = [
        hook,
        '',
        topic.charAt(0).toUpperCase() + topic.slice(1),
        '',
        `üíæ Save this so you don‚Äôt have to search again.`,
        '',
        [...new Set([topicTag, ...baseTags])].join(' '),
      ];

      outEl.textContent = captionLines.join('\n');
      if (statusEl) statusEl.textContent = '';
    }

    async function copyCaption() {
      const outEl = document.getElementById('captionResult');
      const statusEl = document.getElementById('captionStatus');
      const txt = outEl?.textContent || '';
      if (!txt.trim()) {
        alert('Nothing to copy yet‚Äîgenerate a caption first.');
        return;
      }
      try {
        await navigator.clipboard.writeText(txt);
        if (statusEl) {
          statusEl.textContent = 'Copied to clipboard ‚úî';
          setTimeout(() => {
            if (statusEl.textContent === 'Copied to clipboard ‚úî') {
              statusEl.textContent = '';
            }
          }, 2000);
        }
      } catch (err) {
        alert('Unable to copy automatically. You can select and copy manually.');
      }
    }

    /* ---------- Safe Link Scan ---------- */
    function scanLink() {
      const inputEl = document.getElementById('linkInput');
      const resultEl = document.getElementById('linkResult');
      const value = (inputEl?.value || '').trim();

      if (!value) {
        resultEl.textContent = 'Paste a link to analyze.';
        return;
      }

      let urlText = value;
      if (!/^https?:\/\//i.test(urlText)) {
        urlText = 'https://' + urlText;
      }

      let url;
      try {
        url = new URL(urlText);
      } catch (e) {
        resultEl.innerHTML = `<span class="badge danger">Invalid URL</span> This doesn‚Äôt look like a valid link. Double-check for typos or weird characters.`;
        return;
      }

      const findings = [];
      const hostname = url.hostname;
      const protocol = url.protocol;
      const path = url.pathname + url.search + url.hash;

      const ipRegex = /^(?:\d{1,3}\.){3}\d{1,3}$/;
      const isIpHost = ipRegex.test(hostname);

      if (protocol !== 'https:') {
        findings.push(`<span class="badge danger">No HTTPS</span> This link is not using HTTPS. Avoid entering passwords or payment info.`);
      } else {
        findings.push(`<span class="badge success">HTTPS</span> Connection is using HTTPS (this is necessary but not a guarantee of safety).`);
      }

      const suspiciousTlds = ['.ru', '.cn', '.top', '.click', '.xyz', '.work', '.biz'];
      const tldMatch = hostname.match(/\.[a-z0-9]+$/i);
      if (tldMatch && suspiciousTlds.includes(tldMatch[0].toLowerCase())) {
        findings.push(`<span class="badge warn">Unusual domain ending</span> Domain ends with <b>${tldMatch[0]}</b>, which is sometimes used in spam links.`);
      }

      if (isIpHost) {
        findings.push(`<span class="badge danger">IP address as host</span> Legit brands rarely send links that go directly to a bare IP address.`);
      }

      const subdomains = hostname.split('.');
      if (subdomains.length > 3) {
        findings.push(`<span class="badge warn">Many subdomains</span> This link has a lot of dots: <code>${hostname}</code>. Attackers sometimes hide malicious sites behind long hostnames.`);
      }

      if (/login|verify|reset|invoice|paypal|crypt|gift|bonus/i.test(path)) {
        findings.push(`<span class="badge warn">Suspicious words in URL</span> The path contains words commonly used in phishing pages.`);
      }

      if (value.length > 140) {
        findings.push(`<span class="badge warn">Very long URL</span> Extra-long links can be used to hide tracking and redirects.`);
      }

      const output = [];
      output.push(`Host: <code>${hostname}</code>`);
      output.push(`Protocol: <code>${protocol.replace(':','')}</code>`);
      output.push('');
      if (findings.length === 0) {
        output.push(`<span class="badge success">No obvious red flags</span> Nothing looks immediately suspicious based on structure alone.`);
      } else {
        output.push(`<span class="badge warn">Heuristic findings</span> These are not definitive, just things to be aware of:`);
        output.push('');
        output.push(findings.join('\n'));
      }

      output.push('');
      output.push(`<div class="link-rating">
        <span class="pill-soft">‚ö†Ô∏è This tool does not visit or verify the site and cannot guarantee safety. Always trust your gut and verify with the brand through another channel.</span>
      </div>`);

      resultEl.innerHTML = output.join('\n');
    }

    /* ---------- Mini Content Planner (with Facebook option) ---------- */
    const PLANNER_KEY = 'creatorforge_planner_v1';

    function loadPlanner() {
      const raw = localStorage.getItem(PLANNER_KEY);
      if (!raw) {
        return [];
      }
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    function savePlanner(items) {
      try {
        localStorage.setItem(PLANNER_KEY, JSON.stringify(items));
      } catch {
        // ignore
      }
    }

    function renderPlanner() {
      const listEl = document.getElementById('plannerList');
      if (!listEl) return;
      const items = loadPlanner();
      listEl.innerHTML = '';
      if (!items.length) {
        const li = document.createElement('li');
        li.innerHTML = `<span class="planner-meta">No items yet. Add your first idea above.</span>`;
        listEl.appendChild(li);
        return;
      }
      items.forEach((item, index) => {
        const li = document.createElement('li');
        const left = document.createElement('div');
        const right = document.createElement('div');
        const title = document.createElement('div');
        title.className = 'planner-title';
        title.textContent = item.title || '(Untitled idea)';
        const meta = document.createElement('div');
        meta.className = 'planner-meta';
        meta.textContent = [item.platform, item.when].filter(Boolean).join(' ‚Ä¢ ');
        left.appendChild(title);
        left.appendChild(meta);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn-small';
        removeBtn.style.fontSize = '0.65rem';
        removeBtn.textContent = 'Remove';
        removeBtn.onclick = () => {
          const current = loadPlanner();
          current.splice(index, 1);
          savePlanner(current);
          renderPlanner();
        };
        right.appendChild(removeBtn);

        li.appendChild(left);
        li.appendChild(right);
        listEl.appendChild(li);
      });
    }

    function addPlanItem() {
      const titleEl = document.getElementById('plannerTitle');
      const platformEl = document.getElementById('plannerPlatform');
      const whenEl = document.getElementById('plannerWhen');

      const title = (titleEl?.value || '').trim();
      const platform = (platformEl?.value || '').trim();
      const when = (whenEl?.value || '').trim();

      if (!title) {
        alert('Add at least a working title for your idea.');
        return;
      }

      const items = loadPlanner();
      items.unshift({
        title,
        platform,
        when,
        createdAt: Date.now()
      });
      savePlanner(items);
      renderPlanner();

      titleEl.value = '';
      whenEl.value = '';
    }

    function clearPlanner() {
      if (!confirm('Clear all planner items for this browser?')) return;
      savePlanner([]);
      renderPlanner();
    }

    /* ---------- Watermark Helper ---------- */
    let wmImage = null;
    let wmBlob = null;

    const wmImageInput = document.getElementById('wmImageInput');
    const wmCanvas = document.getElementById('watermarkCanvas');
    const wmTextInput = document.getElementById('watermarkText');
    const wmPosSelect = document.getElementById('watermarkPosition');
    const wmColorInput = document.getElementById('watermarkColor');
    const wmSizeInput = document.getElementById('watermarkSize');
    const wmSizeLabel = document.getElementById('watermarkSizeLabel');
    const wmOpacityInput = document.getElementById('watermarkOpacity');
    const wmOpacityLabel = document.getElementById('watermarkOpacityLabel');
    const wmDownloadBtn = document.getElementById('downloadWatermarkBtn');
    const wmPreviewEmpty = document.getElementById('wmPreviewEmpty');
    const wmPreviewMeta = document.getElementById('wmPreviewMeta');
    const wmPreviewStatus = document.getElementById('wmPreviewStatus');

    function setWatermarkPreviewVisible(show) {
      if (wmCanvas) wmCanvas.style.display = show ? 'block' : 'none';
      if (wmPreviewEmpty) wmPreviewEmpty.style.display = show ? 'none' : 'block';
    }

    function setWatermarkPreviewMeta(text) {
      if (wmPreviewMeta) wmPreviewMeta.textContent = text;
    }

    function setWatermarkPreviewStatus(text) {
      if (wmPreviewStatus) wmPreviewStatus.textContent = text;
    }

    function queueWatermarkLivePreview() {
      renderWatermarkPreview({ silent: true, allowBlankText: true });
    }

    if (wmSizeInput && wmSizeLabel) {
      wmSizeInput.addEventListener('input', () => {
        wmSizeLabel.textContent = wmSizeInput.value + 'px';
        queueWatermarkLivePreview();
      });
    }

    if (wmOpacityInput && wmOpacityLabel) {
      wmOpacityInput.addEventListener('input', () => {
        wmOpacityLabel.textContent = wmOpacityInput.value + '%';
        queueWatermarkLivePreview();
      });
    }

    if (wmImageInput) {
      wmImageInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            wmImage = img;
            wmBlob = null;
            if (wmDownloadBtn) wmDownloadBtn.disabled = true;
            queueWatermarkLivePreview();
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    function hexToRgb(hex) {
      const cleaned = hex.replace('#', '');
      const match = cleaned.match(/^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
      if (!match) return null;
      return {
        r: parseInt(match[1], 16),
        g: parseInt(match[2], 16),
        b: parseInt(match[3], 16),
      };
    }

    function renderWatermarkPreview(options = {}) {
      const silent = !!options.silent;
      const allowBlankText = !!options.allowBlankText;

      if (!wmImage) {
        if (!silent) alert('Upload a base image first.');
        setWatermarkPreviewVisible(false);
        setWatermarkPreviewMeta('No image loaded');
        setWatermarkPreviewStatus('Upload an image to start the live preview.');
        return false;
      }

      const text = (wmTextInput?.value || '').trim();
      if (!text && !allowBlankText) {
        if (!silent) alert('Add some watermark text (e.g. @yourhandle).');
        return false;
      }

      const pos = wmPosSelect?.value || 'bottom-right';
      const colorHex = wmColorInput?.value || '#ffffff';
      const size = parseInt(wmSizeInput?.value || '32', 10);
      const opacity = (parseInt(wmOpacityInput?.value || '70', 10) || 70) / 100;

      const rgb = hexToRgb(colorHex) || { r: 255, g: 255, b: 255 };

      const canvas = wmCanvas;
      const ctx = canvas.getContext('2d');
      canvas.width = wmImage.width;
      canvas.height = wmImage.height;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(wmImage, 0, 0, canvas.width, canvas.height);
      setWatermarkPreviewVisible(true);
      setWatermarkPreviewMeta(`${canvas.width}x${canvas.height}`);

      if (!text) {
        wmBlob = null;
        if (wmDownloadBtn) wmDownloadBtn.disabled = true;
        setWatermarkPreviewStatus('Base image loaded. Add watermark text to enable download.');
        return true;
      }

      ctx.font = `600 ${size}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textBaseline = 'bottom';

      const padding = Math.max(size * 0.4, 8);
      const textMetrics = ctx.measureText(text);
      const textWidth = textMetrics.width;
      const textHeight = size;

      let x = padding;
      let y = canvas.height - padding;

      if (pos === 'bottom-right') {
        x = canvas.width - padding - textWidth;
        y = canvas.height - padding;
      } else if (pos === 'bottom-left') {
        x = padding;
        y = canvas.height - padding;
      } else if (pos === 'top-right') {
        x = canvas.width - padding - textWidth;
        y = padding + textHeight;
      } else if (pos === 'top-left') {
        x = padding;
        y = padding + textHeight;
      } else if (pos === 'center') {
        x = (canvas.width - textWidth) / 2;
        y = (canvas.height + textHeight) / 2;
      }

      ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.45})`;
      const shadowPadding = size * 0.35;
      const boxX = x - shadowPadding;
      const boxY = y - textHeight - shadowPadding * 0.4;
      const boxW = textWidth + shadowPadding * 2;
      const boxH = textHeight + shadowPadding * 0.9;
      ctx.fillRect(boxX, boxY, boxW, boxH);

      ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
      ctx.fillText(text, x, y);

      setWatermarkPreviewStatus(`Live preview updated (${pos}, ${size}px, ${Math.round(opacity * 100)}%).`);

      canvas.toBlob((blob) => {
        if (!blob) return;
        wmBlob = blob;
        if (wmDownloadBtn) wmDownloadBtn.disabled = false;
      }, 'image/png', 0.95);
      return true;
    }

    wmTextInput?.addEventListener('input', queueWatermarkLivePreview);
    wmPosSelect?.addEventListener('change', queueWatermarkLivePreview);
    wmColorInput?.addEventListener('input', queueWatermarkLivePreview);

    function previewWatermark() {
      renderWatermarkPreview({ silent: false, allowBlankText: false });
    }

    function downloadWatermarkedImage() {
      if (!wmBlob) {
        alert('No watermarked image yet. Click "Preview watermark" first.');
        return;
      }
      const url = URL.createObjectURL(wmBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'creatorforge-watermarked.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* ---------- Thumbnail Starter ---------- */
    let thumbBlob = null;

    const thumbCanvas = document.getElementById('thumbCanvas');
    const thumbTitleInput = document.getElementById('thumbTitle');
    const thumbSubtitleInput = document.getElementById('thumbSubtitle');
    const thumbPresetSelect = document.getElementById('thumbPreset');
    const thumbLayoutSelect = document.getElementById('thumbLayout');
    const thumbStyleSelect = document.getElementById('thumbStyle');
    const thumbDownloadBtn = document.getElementById('downloadThumbBtn');
    const thumbPreviewEmpty = document.getElementById('thumbPreviewEmpty');
    const thumbPreviewMeta = document.getElementById('thumbPreviewMeta');
    const thumbPreviewStatus = document.getElementById('thumbPreviewStatus');

    function setThumbPreviewVisible(show) {
      if (thumbCanvas) thumbCanvas.style.display = show ? 'block' : 'none';
      if (thumbPreviewEmpty) thumbPreviewEmpty.style.display = show ? 'none' : 'block';
    }

    function setThumbPreviewMeta(text) {
      if (thumbPreviewMeta) thumbPreviewMeta.textContent = text;
    }

    function setThumbPreviewStatus(text) {
      if (thumbPreviewStatus) thumbPreviewStatus.textContent = text;
    }

    function queueThumbnailLivePreview() {
      generateThumbnail({ silent: true });
    }

    function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight, align = 'center') {
      if (!text) return y;
      const words = text.split(' ');
      let line = '';
      let lines = [];

      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && i > 0) {
          lines.push(line.trim());
          line = words[i] + ' ';
        } else {
          line = testLine;
        }
      }
      if (line.trim()) lines.push(line.trim());

      ctx.textAlign = align;
      let currentY = y;
      lines.forEach(l => {
        ctx.fillText(l, x, currentY);
        currentY += lineHeight;
      });
      return currentY;
    }

    function generateThumbnail(options = {}) {
      const silent = !!options.silent;
      const title = (thumbTitleInput?.value || '').trim();
      const subtitle = (thumbSubtitleInput?.value || '').trim();
      const preset = thumbPresetSelect?.value || '1280x720';
      const layout = thumbLayoutSelect?.value || 'center';
      const style = thumbStyleSelect?.value || 'dark';

      if (!title) {
        thumbBlob = null;
        if (thumbDownloadBtn) thumbDownloadBtn.disabled = true;
        setThumbPreviewVisible(false);
        setThumbPreviewMeta('No thumbnail generated');
        setThumbPreviewStatus('Type a main title to start the live preview.');
        if (!silent) alert('Add main title text first.');
        return;
      }

      const [w, h] = preset.split('x').map(Number);
      const canvas = thumbCanvas;
      const ctx = canvas.getContext('2d');
      canvas.width = w;
      canvas.height = h;

      if (style === 'neon') {
        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#0b1020');
        grad.addColorStop(0.4, '#2a1a4f');
        grad.addColorStop(0.8, '#0b4854');
        grad.addColorStop(1, '#05070b');
        ctx.fillStyle = grad;
      } else if (style === 'soft') {
        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#f9e6ff');
        grad.addColorStop(0.5, '#e3f6ff');
        grad.addColorStop(1, '#fdf4e6');
        ctx.fillStyle = grad;
      } else {
        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#05070b');
        grad.addColorStop(0.6, '#121829');
        grad.addColorStop(1, '#05070b');
        ctx.fillStyle = grad;
      }
      ctx.fillRect(0, 0, w, h);

      if (layout === 'bottom') {
        ctx.fillStyle = style === 'soft' ? 'rgba(0,0,0,0.16)' : 'rgba(0,0,0,0.6)';
        ctx.fillRect(0, h * 0.55, w, h * 0.45);
      } else if (layout === 'left') {
        ctx.fillStyle = style === 'soft' ? 'rgba(0,0,0,0.12)' : 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, w * 0.52, h);
      }

      if (style === 'soft') {
        ctx.fillStyle = '#111827';
      } else {
        ctx.fillStyle = '#f9fbff';
      }

      let centerX = w / 2;
      let startY = h / 2;
      let maxWidth = w * 0.8;
      let align = 'center';

      if (layout === 'bottom') {
        startY = h * 0.68;
        maxWidth = w * 0.88;
        align = 'center';
      } else if (layout === 'left') {
        centerX = w * 0.26;
        startY = h * 0.34;
        maxWidth = w * 0.42;
        align = 'center';
      }

      const baseFontSize = Math.min(Math.max(w / 16, 32), 72);
      ctx.font = `800 ${baseFontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textBaseline = 'middle';

      let lineHeight = baseFontSize * 1.2;
      let titleY = startY;

      if (layout === 'center') {
        titleY = h / 2 - baseFontSize * (subtitle ? 0.4 : 0);
      }

      let nextY = drawWrappedText(ctx, title.toUpperCase(), centerX, titleY, maxWidth, lineHeight, align);

      if (subtitle) {
        const subtitleSize = baseFontSize * 0.55;
        ctx.font = `600 ${subtitleSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
        ctx.fillStyle = style === 'soft' ? '#374151' : '#d1e4ff';
        const subLineHeight = subtitleSize * 1.25;
        let subtitleY = nextY + subtitleSize * 0.4;
        if (layout === 'center') {
          subtitleY = nextY + subtitleSize * 0.5;
        }
        drawWrappedText(ctx, subtitle, centerX, subtitleY, maxWidth, subLineHeight, align);
      }

      if (style !== 'soft') {
        ctx.strokeStyle = 'rgba(160,240,255,0.55)';
        ctx.lineWidth = Math.max(w / 650, 1.2);
        ctx.strokeRect(w * 0.03, h * 0.04, w * 0.94, h * 0.92);
      }

      setThumbPreviewVisible(true);
      setThumbPreviewMeta(`${w}x${h} | ${layout} | ${style}`);
      setThumbPreviewStatus('Live preview updated. PNG export will match this canvas.');

      canvas.toBlob((blob) => {
        if (!blob) return;
        thumbBlob = blob;
        if (thumbDownloadBtn) thumbDownloadBtn.disabled = false;
      }, 'image/png', 0.95);
    }

    thumbTitleInput?.addEventListener('input', queueThumbnailLivePreview);
    thumbSubtitleInput?.addEventListener('input', queueThumbnailLivePreview);
    thumbPresetSelect?.addEventListener('change', queueThumbnailLivePreview);
    thumbLayoutSelect?.addEventListener('change', queueThumbnailLivePreview);
    thumbStyleSelect?.addEventListener('change', queueThumbnailLivePreview);

    function downloadThumbnail() {
      if (!thumbBlob) {
        alert('No generated thumbnail yet. Click "Generate thumbnail" first.');
        return;
      }
      const url = URL.createObjectURL(thumbBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'creatorforge-thumbnail.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* ---------- Photo & Video Collage Maker ---------- */
    const COLLAGE_PRESETS = {
      'square-duo': {
        label: 'Square Duo',
        width: 1080,
        height: 1080,
        tiles: [
          { x: 0, y: 0, w: 0.5, h: 1 },
          { x: 0.5, y: 0, w: 0.5, h: 1 },
        ],
      },
      'square-grid4': {
        label: 'Square Grid 4',
        width: 1080,
        height: 1080,
        tiles: [
          { x: 0, y: 0, w: 0.5, h: 0.5 },
          { x: 0.5, y: 0, w: 0.5, h: 0.5 },
          { x: 0, y: 0.5, w: 0.5, h: 0.5 },
          { x: 0.5, y: 0.5, w: 0.5, h: 0.5 },
        ],
      },
      'portrait-feature': {
        label: 'Portrait Feature 3',
        width: 1080,
        height: 1350,
        tiles: [
          { x: 0, y: 0, w: 0.58, h: 1 },
          { x: 0.58, y: 0, w: 0.42, h: 0.5 },
          { x: 0.58, y: 0.5, w: 0.42, h: 0.5 },
        ],
      },
      'story-split3': {
        label: 'Story Split 3',
        width: 1080,
        height: 1920,
        tiles: [
          { x: 0, y: 0, w: 1, h: 0.54 },
          { x: 0, y: 0.54, w: 0.5, h: 0.46 },
          { x: 0.5, y: 0.54, w: 0.5, h: 0.46 },
        ],
      },
      'story-grid4': {
        label: 'Vertical Grid 4',
        width: 1080,
        height: 1920,
        tiles: [
          { x: 0, y: 0, w: 0.5, h: 0.5 },
          { x: 0.5, y: 0, w: 0.5, h: 0.5 },
          { x: 0, y: 0.5, w: 0.5, h: 0.5 },
          { x: 0.5, y: 0.5, w: 0.5, h: 0.5 },
        ],
      },
      'widescreen-feature': {
        label: 'Widescreen Feature 3',
        width: 1920,
        height: 1080,
        tiles: [
          { x: 0, y: 0, w: 0.66, h: 1 },
          { x: 0.66, y: 0, w: 0.34, h: 0.5 },
          { x: 0.66, y: 0.5, w: 0.34, h: 0.5 },
        ],
      },
    };

    const collageMediaInput = document.getElementById('collageMediaInput');
    const collagePresetInput = document.getElementById('collagePreset');
    const collageBgInput = document.getElementById('collageBg');
    const collageGapInput = document.getElementById('collageGap');
    const collageGapLabel = document.getElementById('collageGapLabel');
    const collageRadiusInput = document.getElementById('collageRadius');
    const collageRadiusLabel = document.getElementById('collageRadiusLabel');
    const collageZoomInput = document.getElementById('collageZoom');
    const collageZoomLabel = document.getElementById('collageZoomLabel');
    const collageSelectedTileBadge = document.getElementById('collageSelectedTileBadge');
    const collageSelectedMediaLabel = document.getElementById('collageSelectedMediaLabel');
    const collageSlotList = document.getElementById('collageSlotList');
    const collageStatusEl = document.getElementById('collageStatus');
    const collageCanvas = document.getElementById('collageCanvas');
    const collagePlaybackBtn = document.getElementById('collagePlaybackBtn');
    const collageDownloadPngBtn = document.getElementById('downloadCollagePngBtn');
    const collageDownloadVideoBtn = document.getElementById('downloadCollageVideoBtn');
    const collageExportSecondsInput = document.getElementById('collageExportSeconds');

    let collageMedia = [];
    let collageSlots = [];
    let collageSelectedTileIndex = -1;
    let collageTileRectsCache = [];
    let collageTileMetricsCache = [];
    let collageDragState = null;
    let collageRafId = 0;
    let collageIsRecording = false;
    let collageHideSelection = false;
    let collageToolInitialized = false;

    function collageClamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function setCollageStatus(message) {
      if (collageStatusEl) collageStatusEl.textContent = message || '';
    }

    function getCollagePresetConfig() {
      const key = collagePresetInput?.value || 'portrait-feature';
      return COLLAGE_PRESETS[key] || COLLAGE_PRESETS['portrait-feature'];
    }

    function getCollageIntValue(inputEl, fallback) {
      const value = parseInt(inputEl?.value || String(fallback), 10);
      return Number.isFinite(value) ? value : fallback;
    }

    function collageHasPlayingVideos() {
      return collageMedia.some(item =>
        item.kind === 'video' &&
        item.ready &&
        !item.element.paused &&
        !item.element.ended
      );
    }

    function updateCollageButtons() {
      const hasMedia = collageMedia.length > 0;
      const hasVideos = collageMedia.some(item => item.kind === 'video');
      if (collageDownloadPngBtn) collageDownloadPngBtn.disabled = !hasMedia;
      if (collageDownloadVideoBtn) collageDownloadVideoBtn.disabled = !hasVideos || collageIsRecording;
      if (collagePlaybackBtn) {
        collagePlaybackBtn.disabled = !hasVideos || collageIsRecording;
        collagePlaybackBtn.textContent = collageHasPlayingVideos() ? 'Pause videos' : 'Play videos';
      }
    }

    function updateCollageZoomLabel() {
      const slot = collageSlots[collageSelectedTileIndex];
      const pct = slot ? Math.round((slot.zoom || 1) * 100) : 100;
      const safePct = collageClamp(pct, 100, 240);
      if (collageZoomInput && document.activeElement !== collageZoomInput) {
        collageZoomInput.value = String(safePct);
      }
      if (collageZoomLabel) collageZoomLabel.textContent = `${safePct}%`;
    }

    function updateCollageLabels() {
      const gap = collageClamp(getCollageIntValue(collageGapInput, 12), 0, 40);
      const radius = collageClamp(getCollageIntValue(collageRadiusInput, 14), 0, 40);
      if (collageGapInput) collageGapInput.value = String(gap);
      if (collageRadiusInput) collageRadiusInput.value = String(radius);
      if (collageGapLabel) collageGapLabel.textContent = `${gap}px`;
      if (collageRadiusLabel) collageRadiusLabel.textContent = `${radius}px`;
      updateCollageZoomLabel();
    }

    function updateCollageSelectedTileUI() {
      if (!collageSlots.length || collageSelectedTileIndex < 0 || collageSelectedTileIndex >= collageSlots.length) {
        if (collageSelectedTileBadge) collageSelectedTileBadge.textContent = 'Tile: none';
        if (collageSelectedMediaLabel) {
          collageSelectedMediaLabel.textContent = 'Select a tile in the preview, then drag to reposition.';
        }
        updateCollageZoomLabel();
        return;
      }

      const slot = collageSlots[collageSelectedTileIndex];
      const media = typeof slot.mediaIndex === 'number' ? collageMedia[slot.mediaIndex] : null;
      if (collageSelectedTileBadge) collageSelectedTileBadge.textContent = `Tile ${collageSelectedTileIndex + 1} selected`;
      if (collageSelectedMediaLabel) {
        if (media) {
          const typeText = media.kind === 'video' ? 'Video' : 'Photo';
          collageSelectedMediaLabel.textContent = `${typeText}: ${media.name || `Item ${slot.mediaIndex + 1}`} (drag in preview to slide)`;
        } else {
          collageSelectedMediaLabel.textContent = 'This tile is empty. Pick media from the tile list below.';
        }
      }
      updateCollageZoomLabel();
    }

    function collagedownloadBlob(blob, fileName) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function collageRoundRectPath(ctx, x, y, w, h, r) {
      const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      if (radius <= 0) {
        ctx.rect(x, y, w, h);
        return;
      }
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function getCollageTileRects() {
      const preset = getCollagePresetConfig();
      if (!preset || !collageCanvas) return [];
      const gap = collageClamp(getCollageIntValue(collageGapInput, 12), 0, 40);
      const halfGap = gap / 2;
      return preset.tiles.map(tile => {
        let x = tile.x * collageCanvas.width + halfGap;
        let y = tile.y * collageCanvas.height + halfGap;
        let w = tile.w * collageCanvas.width - gap;
        let h = tile.h * collageCanvas.height - gap;
        x = Math.round(x);
        y = Math.round(y);
        w = Math.max(8, Math.round(w));
        h = Math.max(8, Math.round(h));
        return { x, y, w, h };
      });
    }

    function getCollageMediaSourceSize(media) {
      if (!media || !media.element) return null;
      if (media.kind === 'video') {
        const vw = media.element.videoWidth;
        const vh = media.element.videoHeight;
        if (!vw || !vh) return null;
        return { width: vw, height: vh };
      }
      const iw = media.element.naturalWidth || media.element.width;
      const ih = media.element.naturalHeight || media.element.height;
      if (!iw || !ih) return null;
      return { width: iw, height: ih };
    }

    function getCollageSlotDrawMetrics(media, slot, rect) {
      const source = getCollageMediaSourceSize(media);
      if (!source) return null;
      const zoom = Math.max(1, Number(slot?.zoom) || 1);
      const baseScale = Math.max(rect.w / source.width, rect.h / source.height);
      const drawW = source.width * baseScale * zoom;
      const drawH = source.height * baseScale * zoom;
      const maxPanX = Math.max(0, (drawW - rect.w) / 2);
      const maxPanY = Math.max(0, (drawH - rect.h) / 2);
      const panX = maxPanX > 0 ? collageClamp(Number(slot?.panX) || 0, -1, 1) : 0;
      const panY = maxPanY > 0 ? collageClamp(Number(slot?.panY) || 0, -1, 1) : 0;
      const dx = rect.x + (rect.w - drawW) / 2 + panX * maxPanX;
      const dy = rect.y + (rect.h - drawH) / 2 + panY * maxPanY;
      return { drawW, drawH, dx, dy, maxPanX, maxPanY };
    }

    function drawCollagePlaceholderTile(ctx, rect, index) {
      const grad = ctx.createLinearGradient(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h);
      grad.addColorStop(0, 'rgba(36, 49, 73, 0.9)');
      grad.addColorStop(1, 'rgba(11, 14, 23, 0.98)');
      ctx.fillStyle = grad;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);

      ctx.fillStyle = 'rgba(160, 240, 255, 0.14)';
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
      ctx.lineWidth = 1;
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.w - 1, rect.h - 1);
      ctx.setLineDash([]);

      const labelSize = Math.max(14, Math.min(rect.w, rect.h) * 0.06);
      ctx.fillStyle = 'rgba(240, 246, 255, 0.95)';
      ctx.font = `600 ${labelSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`Tile ${index + 1}`, rect.x + rect.w / 2, rect.y + rect.h / 2 - labelSize * 0.2);

      ctx.fillStyle = 'rgba(158, 168, 196, 0.92)';
      ctx.font = `500 ${Math.max(11, labelSize * 0.58)}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      ctx.fillText('Select media below', rect.x + rect.w / 2, rect.y + rect.h / 2 + labelSize * 0.95);
    }

    function drawCollageTileOverlay(ctx, rect, index, isSelected, media) {
      const label = `Tile ${index + 1}${media ? '' : ' (empty)'}`;
      const textWidth = ctx.measureText(label).width;
      const labelW = Math.min(rect.w - 10, Math.max(70, textWidth + 16));
      const labelH = 20;

      ctx.fillStyle = isSelected ? 'rgba(160, 240, 255, 0.2)' : 'rgba(0, 0, 0, 0.34)';
      ctx.fillRect(rect.x + 6, rect.y + 6, labelW, labelH);

      ctx.fillStyle = isSelected ? '#eaffff' : '#d9e4ff';
      ctx.font = '600 11px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, rect.x + 14, rect.y + 16);

      if (!isSelected || collageHideSelection) return;

      ctx.save();
      ctx.strokeStyle = 'rgba(160, 240, 255, 0.95)';
      ctx.lineWidth = 2;
      ctx.setLineDash([9, 6]);
      collageRoundRectPath(ctx, rect.x + 1, rect.y + 1, rect.w - 2, rect.h - 2, Math.max(0, collageClamp(getCollageIntValue(collageRadiusInput, 14), 0, 40) - 1));
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle = 'rgba(160, 240, 255, 0.95)';
      [
        [rect.x + 10, rect.y + 10],
        [rect.x + rect.w - 10, rect.y + 10],
        [rect.x + 10, rect.y + rect.h - 10],
        [rect.x + rect.w - 10, rect.y + rect.h - 10],
      ].forEach(([hx, hy]) => {
        ctx.beginPath();
        ctx.arc(hx, hy, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function renderCollagePreview() {
      if (!collageCanvas) return;
      const ctx = collageCanvas.getContext('2d');
      if (!ctx) return;

      const preset = getCollagePresetConfig();
      if (collageCanvas.width !== preset.width) collageCanvas.width = preset.width;
      if (collageCanvas.height !== preset.height) collageCanvas.height = preset.height;

      ctx.clearRect(0, 0, collageCanvas.width, collageCanvas.height);
      ctx.fillStyle = collageBgInput?.value || '#0b1020';
      ctx.fillRect(0, 0, collageCanvas.width, collageCanvas.height);

      const tileRects = getCollageTileRects();
      const radius = collageClamp(getCollageIntValue(collageRadiusInput, 14), 0, 40);
      collageTileRectsCache = tileRects;
      collageTileMetricsCache = [];

      tileRects.forEach((rect, index) => {
        const slot = collageSlots[index] || { mediaIndex: null, panX: 0, panY: 0, zoom: 1 };
        const media = typeof slot.mediaIndex === 'number' ? collageMedia[slot.mediaIndex] : null;

        ctx.save();
        collageRoundRectPath(ctx, rect.x, rect.y, rect.w, rect.h, radius);
        ctx.clip();

        if (media && media.ready) {
          const metrics = getCollageSlotDrawMetrics(media, slot, rect);
          if (metrics) {
            collageTileMetricsCache[index] = metrics;
            try {
              ctx.drawImage(media.element, metrics.dx, metrics.dy, metrics.drawW, metrics.drawH);
            } catch {
              drawCollagePlaceholderTile(ctx, rect, index);
            }
          } else {
            drawCollagePlaceholderTile(ctx, rect, index);
          }
        } else {
          drawCollagePlaceholderTile(ctx, rect, index);
        }
        ctx.restore();

        ctx.save();
        ctx.font = '600 11px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        drawCollageTileOverlay(ctx, rect, index, index === collageSelectedTileIndex, media);
        ctx.restore();
      });

      if (!collageMedia.length) {
        ctx.fillStyle = 'rgba(255,255,255,0.045)';
        ctx.fillRect(0, 0, collageCanvas.width, collageCanvas.height);
        ctx.fillStyle = '#f0f6ff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = `700 ${Math.max(20, Math.min(collageCanvas.width, collageCanvas.height) * 0.04)}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
        ctx.fillText('Upload photos or videos to start', collageCanvas.width / 2, collageCanvas.height / 2 - 14);
        ctx.fillStyle = 'rgba(207, 217, 255, 0.9)';
        ctx.font = `500 ${Math.max(12, Math.min(collageCanvas.width, collageCanvas.height) * 0.018)}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
        ctx.fillText('Live preview = export composition', collageCanvas.width / 2, collageCanvas.height / 2 + 18);
      }
    }

    function collageNeedsAnimationFrame() {
      return collageIsRecording || collageHasPlayingVideos();
    }

    function ensureCollageRenderLoop() {
      if (collageRafId) return;
      const tick = () => {
        collageRafId = 0;
        renderCollagePreview();
        if (collageNeedsAnimationFrame()) {
          collageRafId = requestAnimationFrame(tick);
        }
      };
      collageRafId = requestAnimationFrame(tick);
    }

    function requestCollageRender() {
      renderCollagePreview();
      if (collageNeedsAnimationFrame()) ensureCollageRenderLoop();
    }

    function revokeCollageMedia() {
      collageMedia.forEach(item => {
        if (item.kind === 'video' && item.element) {
          try {
            item.element.pause();
          } catch {
            // ignore
          }
        }
        if (item.objectUrl) URL.revokeObjectURL(item.objectUrl);
      });
      collageMedia = [];
    }

    function syncCollageSlotsToPreset(options = {}) {
      const preset = getCollagePresetConfig();
      const previous = options.reset ? [] : collageSlots;

      collageSlots = preset.tiles.map((_, index) => {
        const prev = previous[index];
        const nextSlot = prev ? {
          mediaIndex: prev.mediaIndex,
          panX: Number(prev.panX) || 0,
          panY: Number(prev.panY) || 0,
          zoom: Math.max(1, Number(prev.zoom) || 1),
        } : {
          mediaIndex: null,
          panX: 0,
          panY: 0,
          zoom: 1,
        };

        if (
          typeof nextSlot.mediaIndex !== 'number' ||
          nextSlot.mediaIndex < 0 ||
          nextSlot.mediaIndex >= collageMedia.length
        ) {
          nextSlot.mediaIndex = null;
        }
        return nextSlot;
      });

      if (collageMedia.length && options.autoAssign !== false) {
        collageSlots.forEach((slot, index) => {
          if (slot.mediaIndex == null) {
            // Repeat available uploads across remaining tiles (Canva-style default behavior).
            slot.mediaIndex = index % collageMedia.length;
          }
        });
      }

      if (!collageSlots.length) {
        collageSelectedTileIndex = -1;
      } else if (collageSelectedTileIndex < 0 || collageSelectedTileIndex >= collageSlots.length) {
        collageSelectedTileIndex = 0;
      }

      renderCollageSlotList();
      updateCollageSelectedTileUI();
    }

    function renderCollageSlotList() {
      if (!collageSlotList) return;
      collageSlotList.innerHTML = '';

      if (!collageSlots.length) {
        const empty = document.createElement('div');
        empty.className = 'tiny';
        empty.textContent = 'Choose a collage layout to set up tiles.';
        collageSlotList.appendChild(empty);
        return;
      }

      collageSlots.forEach((slot, index) => {
        const row = document.createElement('div');
        row.className = 'collage-slot-row';

        const label = document.createElement('label');
        label.textContent = `Tile ${index + 1}`;
        label.htmlFor = `collageSlotMedia-${index}`;

        const select = document.createElement('select');
        select.id = `collageSlotMedia-${index}`;

        const emptyOpt = document.createElement('option');
        emptyOpt.value = '';
        emptyOpt.textContent = 'Empty tile';
        select.appendChild(emptyOpt);

        collageMedia.forEach((media, mediaIndex) => {
          const opt = document.createElement('option');
          opt.value = String(mediaIndex);
          const prefix = media.kind === 'video' ? 'Video' : 'Photo';
          const shortName = (media.name || `${prefix} ${mediaIndex + 1}`).slice(0, 30);
          opt.textContent = `${prefix} ${mediaIndex + 1}: ${shortName}`;
          select.appendChild(opt);
        });

        select.value = slot.mediaIndex == null ? '' : String(slot.mediaIndex);
        select.addEventListener('change', () => {
          const chosen = select.value === '' ? null : parseInt(select.value, 10);
          collageSlots[index].mediaIndex = Number.isFinite(chosen) ? chosen : null;
          collageSlots[index].panX = 0;
          collageSlots[index].panY = 0;
          collageSlots[index].zoom = 1;
          collageSelectTile(index);
          requestCollageRender();
        });

        const selectTileBtn = document.createElement('button');
        selectTileBtn.type = 'button';
        selectTileBtn.className = `collage-tile-pill${index === collageSelectedTileIndex ? ' active' : ''}`;
        selectTileBtn.textContent = 'Select';
        selectTileBtn.addEventListener('click', () => collageSelectTile(index));

        row.appendChild(label);
        row.appendChild(select);
        row.appendChild(selectTileBtn);
        collageSlotList.appendChild(row);
      });
    }

    function collageSelectTile(index) {
      if (!Number.isInteger(index) || index < 0 || index >= collageSlots.length) return;
      collageSelectedTileIndex = index;
      renderCollageSlotList();
      updateCollageSelectedTileUI();
      requestCollageRender();
    }

    function resetCollageSelectedTile() {
      if (collageSelectedTileIndex < 0 || collageSelectedTileIndex >= collageSlots.length) {
        alert('Select a collage tile first.');
        return;
      }
      const slot = collageSlots[collageSelectedTileIndex];
      slot.panX = 0;
      slot.panY = 0;
      slot.zoom = 1;
      updateCollageSelectedTileUI();
      requestCollageRender();
    }

    function getCollageCanvasPoint(event) {
      if (!collageCanvas) return null;
      const rect = collageCanvas.getBoundingClientRect();
      if (!rect.width || !rect.height) return null;
      return {
        x: (event.clientX - rect.left) * (collageCanvas.width / rect.width),
        y: (event.clientY - rect.top) * (collageCanvas.height / rect.height),
      };
    }

    function getCollageTileIndexAtPoint(point) {
      if (!point) return -1;
      for (let i = collageTileRectsCache.length - 1; i >= 0; i--) {
        const rect = collageTileRectsCache[i];
        if (!rect) continue;
        if (
          point.x >= rect.x &&
          point.x <= rect.x + rect.w &&
          point.y >= rect.y &&
          point.y <= rect.y + rect.h
        ) {
          return i;
        }
      }
      return -1;
    }

    function onCollagePointerDown(event) {
      if (!collageCanvas) return;
      const point = getCollageCanvasPoint(event);
      const tileIndex = getCollageTileIndexAtPoint(point);
      if (tileIndex < 0) return;

      collageSelectTile(tileIndex);
      event.preventDefault();

      const slot = collageSlots[tileIndex];
      const media = slot && typeof slot.mediaIndex === 'number' ? collageMedia[slot.mediaIndex] : null;
      const metrics = collageTileMetricsCache[tileIndex];
      if (!media || !metrics) return;

      collageDragState = {
        pointerId: event.pointerId,
        tileIndex,
        startX: point.x,
        startY: point.y,
        startPanX: Number(slot.panX) || 0,
        startPanY: Number(slot.panY) || 0,
      };

      try {
        collageCanvas.setPointerCapture(event.pointerId);
      } catch {
        // ignore
      }
      collageCanvas.classList.add('dragging');
    }

    function onCollagePointerMove(event) {
      if (!collageDragState || !collageCanvas) return;
      if (event.pointerId !== collageDragState.pointerId) return;

      const point = getCollageCanvasPoint(event);
      if (!point) return;

      const slot = collageSlots[collageDragState.tileIndex];
      const metrics = collageTileMetricsCache[collageDragState.tileIndex];
      if (!slot || !metrics) return;

      const dx = point.x - collageDragState.startX;
      const dy = point.y - collageDragState.startY;

      slot.panX = metrics.maxPanX > 0
        ? collageClamp(collageDragState.startPanX + (dx / metrics.maxPanX), -1, 1)
        : 0;
      slot.panY = metrics.maxPanY > 0
        ? collageClamp(collageDragState.startPanY + (dy / metrics.maxPanY), -1, 1)
        : 0;

      requestCollageRender();
    }

    function onCollagePointerUp(event) {
      if (!collageDragState || !collageCanvas) return;
      if (event.pointerId !== collageDragState.pointerId) return;
      collageDragState = null;
      collageCanvas.classList.remove('dragging');
      try {
        collageCanvas.releasePointerCapture(event.pointerId);
      } catch {
        // ignore
      }
    }

    function loadCollageImageFile(file) {
      return new Promise((resolve, reject) => {
        const objectUrl = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          resolve({
            kind: 'image',
            name: file.name,
            file,
            objectUrl,
            element: img,
            ready: true,
          });
        };
        img.onerror = () => {
          URL.revokeObjectURL(objectUrl);
          reject(new Error(`Could not load image: ${file.name}`));
        };
        img.src = objectUrl;
      });
    }

    function loadCollageVideoFile(file) {
      return new Promise((resolve, reject) => {
        const objectUrl = URL.createObjectURL(file);
        const video = document.createElement('video');
        video.muted = true;
        video.loop = true;
        video.playsInline = true;
        video.preload = 'auto';
        video.src = objectUrl;

        const cleanupEvents = () => {
          video.onloadeddata = null;
          video.onerror = null;
        };

        video.onloadeddata = () => {
          cleanupEvents();
          resolve({
            kind: 'video',
            name: file.name,
            file,
            objectUrl,
            element: video,
            ready: true,
          });
        };

        video.onerror = () => {
          cleanupEvents();
          URL.revokeObjectURL(objectUrl);
          reject(new Error(`Could not load video: ${file.name}`));
        };

        video.load();
      });
    }

    async function handleCollageMediaSelection() {
      const allFiles = Array.from(collageMediaInput?.files || []);
      const existingCount = collageMedia.length;
      const remainingCapacity = Math.max(0, 8 - existingCount);
      const files = allFiles.slice(0, remainingCapacity);

      if (!allFiles.length) {
        setCollageStatus(existingCount ? 'No new files selected.' : 'Upload photos or videos to start a collage.');
        return;
      }

      if (remainingCapacity <= 0) {
        setCollageStatus('Collage media library is full (8 files max). Reassign tiles from the list or refresh to start over.');
        if (collageMediaInput) collageMediaInput.value = '';
        return;
      }

      const verb = existingCount ? 'Adding' : 'Loading';
      setCollageStatus(`${verb} ${files.length} file${files.length === 1 ? '' : 's'}...`);

      const settled = await Promise.allSettled(files.map(file => (
        file.type.startsWith('video/')
          ? loadCollageVideoFile(file)
          : loadCollageImageFile(file)
      )));

      const loaded = [];
      let failed = 0;
      settled.forEach(result => {
        if (result.status === 'fulfilled') loaded.push(result.value);
        else failed += 1;
      });

      if (!collageSlots.length) {
        syncCollageSlotsToPreset({ reset: true, autoAssign: false });
      } else {
        syncCollageSlotsToPreset({ reset: false, autoAssign: false });
      }

      const firstNewIndex = collageMedia.length;
      collageMedia = collageMedia.concat(loaded);

      if (loaded.length && collageSlots.length) {
        const newMediaIndices = loaded.map((_, i) => firstNewIndex + i);
        let nextNew = 0;
        collageSlots.forEach((slot) => {
          if (slot.mediaIndex == null) {
            slot.mediaIndex = newMediaIndices[nextNew % newMediaIndices.length];
            nextNew += 1;
          }
        });

        // If this is the first upload, ensure all empty tiles are filled (repeat uploaded items).
        if (!existingCount) {
          collageSlots.forEach((slot, index) => {
            if (slot.mediaIndex == null && collageMedia.length) {
              slot.mediaIndex = index % collageMedia.length;
            }
          });
        }
      }

      renderCollageSlotList();
      updateCollageSelectedTileUI();
      updateCollageButtons();
      requestCollageRender();

      if (loaded.some(item => item.kind === 'video')) {
        await playCollageVideos({ quiet: true });
      }

      const photos = collageMedia.filter(item => item.kind === 'image').length;
      const videos = collageMedia.filter(item => item.kind === 'video').length;
      const addedPhotos = loaded.filter(item => item.kind === 'image').length;
      const addedVideos = loaded.filter(item => item.kind === 'video').length;
      const parts = [];
      if (photos) parts.push(`${photos} photo${photos === 1 ? '' : 's'}`);
      if (videos) parts.push(`${videos} video${videos === 1 ? '' : 's'}`);
      if (!parts.length) parts.push('0 files');

      const addedParts = [];
      if (addedPhotos) addedParts.push(`${addedPhotos} photo${addedPhotos === 1 ? '' : 's'}`);
      if (addedVideos) addedParts.push(`${addedVideos} video${addedVideos === 1 ? '' : 's'}`);

      let message = loaded.length
        ? `${existingCount ? 'Added' : 'Loaded'} ${addedParts.length ? addedParts.join(' + ') : `${loaded.length} file${loaded.length === 1 ? '' : 's'}`}. Library now has ${parts.join(' + ')}.`
        : 'No usable files were added.';

      if (allFiles.length > remainingCapacity) {
        message += ` Added first ${Math.min(allFiles.length, remainingCapacity)} of ${allFiles.length} selected (8-file max).`;
      }
      if (failed) message += ` ${failed} failed to load.`;
      if (collageMedia.length > collageSlots.length) {
        const extras = collageMedia.length - collageSlots.length;
        message += ` ${extras} extra item${extras === 1 ? '' : 's'} available in the tile list.`;
      }
      setCollageStatus(message);

      if (collageMediaInput) collageMediaInput.value = '';
    }

    async function playCollageVideos(options = {}) {
      const videos = collageMedia.filter(item => item.kind === 'video' && item.ready);
      if (!videos.length) {
        updateCollageButtons();
        return;
      }

      if (options.resetTime) {
        videos.forEach(item => {
          try {
            item.element.currentTime = 0;
          } catch {
            // ignore
          }
        });
      }

      const results = await Promise.allSettled(videos.map(item => item.element.play()));
      updateCollageButtons();
      if (collageHasPlayingVideos()) {
        ensureCollageRenderLoop();
      } else {
        requestCollageRender();
      }

      if (!options.quiet && results.some(r => r.status === 'rejected') && !collageHasPlayingVideos()) {
        setCollageStatus('Video playback was blocked by this browser. Press Play again to retry.');
      }
    }

    function pauseCollageVideos() {
      collageMedia
        .filter(item => item.kind === 'video' && item.ready)
        .forEach(item => {
          try {
            item.element.pause();
          } catch {
            // ignore
          }
        });
      updateCollageButtons();
      requestCollageRender();
    }

    async function toggleCollagePlayback() {
      if (!collageMedia.some(item => item.kind === 'video')) {
        alert('Add at least one video to use playback controls.');
        return;
      }
      if (collageHasPlayingVideos()) {
        pauseCollageVideos();
        setCollageStatus('Paused collage video preview.');
      } else {
        await playCollageVideos();
        if (collageHasPlayingVideos()) {
          setCollageStatus('Playing collage video preview.');
        }
      }
    }

    function downloadCollagePng() {
      if (!collageMedia.length || !collageCanvas) {
        alert('Upload photos or videos first.');
        return;
      }

      collageHideSelection = true;
      renderCollagePreview();
      collageCanvas.toBlob((blob) => {
        collageHideSelection = false;
        requestCollageRender();
        if (!blob) {
          alert('Could not generate the collage PNG.');
          return;
        }
        collagedownloadBlob(blob, 'creatorforge-collage.png');
        setCollageStatus('Downloaded PNG collage.');
      }, 'image/png', 0.95);
    }

    async function exportCollageVideo() {
      if (collageIsRecording) return;
      if (!collageMedia.some(item => item.kind === 'video')) {
        alert('Add at least one video clip to export a WebM collage.');
        return;
      }
      if (!collageCanvas || typeof collageCanvas.captureStream !== 'function' || typeof MediaRecorder === 'undefined') {
        alert('WebM export is not supported in this browser. PNG export still works.');
        return;
      }

      const seconds = collageClamp(getCollageIntValue(collageExportSecondsInput, 6), 1, 30);
      if (collageExportSecondsInput) collageExportSecondsInput.value = String(seconds);

      const mimeCandidates = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];
      const mimeType = mimeCandidates.find(type => {
        try {
          return typeof MediaRecorder.isTypeSupported !== 'function' || MediaRecorder.isTypeSupported(type);
        } catch {
          return false;
        }
      }) || '';

      const stream = collageCanvas.captureStream(30);
      let recorder;
      try {
        recorder = mimeType
          ? new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 8000000 })
          : new MediaRecorder(stream, { videoBitsPerSecond: 8000000 });
      } catch {
        stream.getTracks().forEach(track => track.stop());
        alert('Could not start WebM recording in this browser.');
        return;
      }

      const chunks = [];
      let exportError = null;
      const recorderDone = new Promise(resolve => {
        recorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) chunks.push(event.data);
        };
        recorder.onerror = (event) => {
          exportError = event.error || new Error('Recorder failed');
        };
        recorder.onstop = resolve;
      });

      const wasPlayingBefore = collageHasPlayingVideos();
      collageIsRecording = true;
      collageHideSelection = true;
      updateCollageButtons();
      setCollageStatus(`Recording ${seconds}s WebM collage...`);

      try {
        await playCollageVideos({ resetTime: true, quiet: true });
        ensureCollageRenderLoop();
        recorder.start(200);
        await new Promise(resolve => setTimeout(resolve, seconds * 1000));
        if (recorder.state !== 'inactive') recorder.stop();
        await recorderDone;

        if (exportError) throw exportError;

        const blob = new Blob(chunks, { type: recorder.mimeType || 'video/webm' });
        if (!blob.size) throw new Error('Empty WebM export');

        collagedownloadBlob(blob, 'creatorforge-collage.webm');
        setCollageStatus(`Downloaded ${seconds}s WebM collage (no audio).`);
      } catch {
        setCollageStatus('WebM export failed in this browser. PNG export is still available.');
        alert('WebM export failed. Try PNG export or a Chromium-based browser.');
      } finally {
        collageIsRecording = false;
        collageHideSelection = false;
        stream.getTracks().forEach(track => track.stop());
        if (!wasPlayingBefore) {
          pauseCollageVideos();
        } else {
          updateCollageButtons();
          ensureCollageRenderLoop();
          requestCollageRender();
        }
        requestCollageRender();
      }
    }

    function initCollageTool() {
      if (collageToolInitialized) return;
      collageToolInitialized = true;
      if (!collageCanvas) return;

      updateCollageLabels();
      syncCollageSlotsToPreset({ reset: true, autoAssign: false });
      updateCollageButtons();
      renderCollageSlotList();
      requestCollageRender();

      collageMediaInput?.addEventListener('change', () => {
        handleCollageMediaSelection();
      });

      collagePresetInput?.addEventListener('change', () => {
        // Preserve existing tile assignments, but fill any new/empty tiles automatically.
        syncCollageSlotsToPreset({ reset: false, autoAssign: true });
        const preset = getCollagePresetConfig();
        setCollageStatus(`Switched to ${preset.label} (${preset.width}x${preset.height}).`);
        requestCollageRender();
      });

      collageBgInput?.addEventListener('input', requestCollageRender);

      collageGapInput?.addEventListener('input', () => {
        updateCollageLabels();
        requestCollageRender();
      });

      collageRadiusInput?.addEventListener('input', () => {
        updateCollageLabels();
        requestCollageRender();
      });

      collageZoomInput?.addEventListener('input', () => {
        const value = collageClamp(getCollageIntValue(collageZoomInput, 100), 100, 240);
        if (collageZoomInput) collageZoomInput.value = String(value);
        if (collageZoomLabel) collageZoomLabel.textContent = `${value}%`;
        if (collageSelectedTileIndex < 0 || collageSelectedTileIndex >= collageSlots.length) return;
        collageSlots[collageSelectedTileIndex].zoom = value / 100;
        requestCollageRender();
      });

      collageCanvas.addEventListener('pointerdown', onCollagePointerDown);
      collageCanvas.addEventListener('pointermove', onCollagePointerMove);
      collageCanvas.addEventListener('pointerup', onCollagePointerUp);
      collageCanvas.addEventListener('pointercancel', onCollagePointerUp);
      collageCanvas.addEventListener('lostpointercapture', () => {
        collageDragState = null;
        collageCanvas.classList.remove('dragging');
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      renderPlanner();
      initCollageTool();
    });
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="creatorforge-bg-remover.js"></script>
</body>
</html>

